<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JSONPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fastjson</a> &gt; <a href="index.source.html" class="el_package">com.alibaba.fastjson</a> &gt; <span class="el_source">JSONPath.java</span></div><h1>JSONPath.java</h1><pre class="source lang-java linenums">package com.alibaba.fastjson;

import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.JSONLexer;
import com.alibaba.fastjson.parser.JSONLexerBase;
import com.alibaba.fastjson.parser.JSONToken;
import com.alibaba.fastjson.parser.ParserConfig;
import com.alibaba.fastjson.parser.deserializer.FieldDeserializer;
import com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer;
import com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;
import com.alibaba.fastjson.serializer.FieldSerializer;
import com.alibaba.fastjson.serializer.JavaBeanSerializer;
import com.alibaba.fastjson.serializer.ObjectSerializer;
import com.alibaba.fastjson.serializer.SerializeConfig;
import com.alibaba.fastjson.util.IOUtils;
import com.alibaba.fastjson.util.TypeUtils;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author wenshao[szujobs@hotmail.com]
 * @since 1.2.0
 */
public class JSONPath implements JSONAware {
<span class="fc" id="L48">    private static ConcurrentMap&lt;String, JSONPath&gt; pathCache  = new ConcurrentHashMap&lt;String, JSONPath&gt;(128, 0.75f, 1);</span>

    private final String                           path;
    private Segment[]                              segments;
    private boolean                                hasRefSegment;

    private SerializeConfig                        serializeConfig;
    private ParserConfig                           parserConfig;

    private boolean                                ignoreNullValue;

    public JSONPath(String path){
<span class="fc" id="L60">        this(path, SerializeConfig.getGlobalInstance(), ParserConfig.getGlobalInstance(), true);</span>
<span class="fc" id="L61">    }</span>

    public JSONPath(String path, boolean ignoreNullValue){
<span class="nc" id="L64">        this(path, SerializeConfig.getGlobalInstance(), ParserConfig.getGlobalInstance(), ignoreNullValue);</span>
<span class="nc" id="L65">    }</span>

<span class="fc" id="L67">    public JSONPath(String path, SerializeConfig serializeConfig, ParserConfig parserConfig, boolean ignoreNullValue){</span>
<span class="fc bfc" id="L68" title="All 4 branches covered.">        if (path == null || path.length() == 0) {</span>
<span class="fc" id="L69">            throw new JSONPathException(&quot;json-path can not be null or empty&quot;);</span>
        }

<span class="fc" id="L72">        this.path = path;</span>
<span class="fc" id="L73">        this.serializeConfig = serializeConfig;</span>
<span class="fc" id="L74">        this.parserConfig = parserConfig;</span>
<span class="fc" id="L75">        this.ignoreNullValue = ignoreNullValue;</span>
<span class="fc" id="L76">    }</span>

    protected void init() {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (segments != null) {</span>
<span class="fc" id="L80">            return;</span>
        }

<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (&quot;*&quot;.equals(path)) {</span>
<span class="fc" id="L84">            this.segments = new Segment[] { WildCardSegment.instance };</span>
        } else {
<span class="fc" id="L86">            JSONPathParser parser = new JSONPathParser(path);</span>
<span class="fc" id="L87">            this.segments = parser.explain();</span>
<span class="fc" id="L88">            this.hasRefSegment = parser.hasRefSegment;</span>
        }
<span class="fc" id="L90">    }</span>

    public boolean isRef() {
        try {
<span class="fc" id="L94">            init();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L96">                Segment segment = segments[i];</span>
<span class="fc" id="L97">                Class segmentType = segment.getClass();</span>
<span class="pc bpc" id="L98" title="1 of 4 branches missed.">                if (segmentType == ArrayAccessSegment.class</span>
                        || segmentType == PropertySegment.class) {
<span class="fc" id="L100">                    continue;</span>
                }
<span class="nc" id="L102">                return false;</span>
            }
<span class="fc" id="L104">            return true;</span>
<span class="fc" id="L105">        } catch (JSONPathException ex) {</span>
            // skip
<span class="fc" id="L107">            return false;</span>
        }
    }

    public Object eval(Object rootObject) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (rootObject == null) {</span>
<span class="fc" id="L113">            return null;</span>
        }

<span class="fc" id="L116">        init();</span>

<span class="fc" id="L118">        Object currentObject = rootObject;</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L120">            Segment segment = segments[i];</span>
<span class="fc" id="L121">            currentObject = segment.eval(this, rootObject, currentObject);</span>
        }
<span class="fc" id="L123">        return currentObject;</span>
    }
    
    /**
     * @since 1.2.76
     * @param rootObject
     * @param clazz
     * @param parserConfig
     * @return
     */
    public &lt;T&gt; T eval(Object rootObject, Type clazz, ParserConfig parserConfig) {
<span class="nc" id="L134">        Object obj = this.eval(rootObject);</span>
<span class="nc" id="L135">        return TypeUtils.cast(obj, clazz, parserConfig);</span>
    }
    
    /**
     * @since 1.2.76
     * @param rootObject
     * @param clazz
     * @return
     */
    public &lt;T&gt; T eval(Object rootObject, Type clazz) {
<span class="nc" id="L145">        return this.eval(rootObject, clazz, ParserConfig.getGlobalInstance());</span>
    }

    public Object extract(DefaultJSONParser parser) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (parser == null) {</span>
<span class="fc" id="L150">            return null;</span>
        }

<span class="fc" id="L153">        init();</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (hasRefSegment) {</span>
<span class="fc" id="L156">            Object root = parser.parse();</span>
<span class="fc" id="L157">            return this.eval(root);</span>
        }

<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (segments.length == 0) {</span>
<span class="fc" id="L161">            return parser.parse();</span>
        }

<span class="fc" id="L164">        Segment lastSegment = segments[segments.length - 1];</span>
<span class="fc bfc" id="L165" title="All 6 branches covered.">        if (lastSegment instanceof TypeSegment</span>
                || lastSegment instanceof FloorSegment
                || lastSegment instanceof MultiIndexSegment) {
<span class="fc" id="L168">            return eval(</span>
<span class="fc" id="L169">                    parser.parse());</span>
        }

<span class="fc" id="L172">        Context context = null;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L174">            Segment segment = segments[i];</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            boolean last = i == segments.length - 1;</span>

<span class="fc bfc" id="L177" title="All 4 branches covered.">            if (context != null &amp;&amp; context.object != null) {</span>
<span class="fc" id="L178">                context.object = segment.eval(this, null, context.object);</span>
<span class="fc" id="L179">                continue;</span>
            }

            boolean eval;

<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (!last) {</span>
<span class="fc" id="L185">                Segment nextSegment = segments[i + 1];</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (segment instanceof PropertySegment</span>
<span class="pc bpc" id="L187" title="3 of 14 branches missed.">                        &amp;&amp; ((PropertySegment) segment).deep</span>
                        &amp;&amp; (nextSegment instanceof ArrayAccessSegment
                            || nextSegment instanceof MultiIndexSegment
                            || nextSegment instanceof MultiPropertySegment
                            || nextSegment instanceof SizeSegment
                            || nextSegment instanceof PropertySegment
                            || nextSegment instanceof FilterSegment))
                {
<span class="fc" id="L195">                    eval = true;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                } else if (nextSegment instanceof ArrayAccessSegment</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">                        &amp;&amp; ((ArrayAccessSegment) nextSegment).index &lt; 0) {</span>
<span class="nc" id="L198">                    eval = true;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                } else if (nextSegment instanceof FilterSegment) {</span>
<span class="fc" id="L200">                    eval = true;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                } else if (segment instanceof WildCardSegment) {</span>
<span class="fc" id="L202">                    eval = true;</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">                }else if(segment instanceof MultiIndexSegment){</span>
<span class="nc" id="L204">                    eval = true;</span>
                } else {
<span class="fc" id="L206">                    eval = false;</span>
                }
<span class="fc" id="L208">            } else {</span>
<span class="fc" id="L209">                eval = true;</span>
            }

<span class="fc" id="L212">            context = new Context(context, eval);</span>
<span class="fc" id="L213">            segment.extract(this, parser, context);</span>
        }

<span class="fc" id="L216">        return context.object;</span>
    }

    private static class Context {
        final Context parent;
        final boolean eval;
        Object object;

<span class="fc" id="L224">        public Context(Context parent, boolean eval) {</span>
<span class="fc" id="L225">            this.parent = parent;</span>
<span class="fc" id="L226">            this.eval = eval;</span>
<span class="fc" id="L227">        }</span>
    }

    public boolean contains(Object rootObject) {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (rootObject == null) {</span>
<span class="fc" id="L232">            return false;</span>
        }

<span class="fc" id="L235">        init();</span>

<span class="fc" id="L237">        Object currentObject = rootObject;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L239">            Object parentObject = currentObject;</span>
<span class="fc" id="L240">            currentObject = segments[i].eval(this, rootObject, currentObject);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (currentObject == null) {</span>
<span class="fc" id="L242">                return false;</span>
            }

<span class="pc bpc" id="L245" title="1 of 4 branches missed.">            if (currentObject == Collections.EMPTY_LIST &amp;&amp; parentObject instanceof List) {</span>
<span class="fc" id="L246">                return ((List) parentObject).contains(currentObject);</span>
            }
        }

<span class="fc" id="L250">        return true;</span>
    }

    @SuppressWarnings(&quot;rawtypes&quot;)
    public boolean containsValue(Object rootObject, Object value) {
<span class="fc" id="L255">        Object currentObject = eval(rootObject);</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (currentObject == value) {</span>
<span class="fc" id="L258">            return true;</span>
        }

<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (currentObject == null) {</span>
<span class="fc" id="L262">            return false;</span>
        }

<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (currentObject instanceof Iterable) {</span>
<span class="fc" id="L266">            Iterator it = ((Iterable) currentObject).iterator();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L268">                Object item = it.next();</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (eq(item, value)) {</span>
<span class="fc" id="L270">                    return true;</span>
                }
<span class="fc" id="L272">            }</span>

<span class="fc" id="L274">            return false;</span>
        }

<span class="fc" id="L277">        return eq(currentObject, value);</span>
    }

    public int size(Object rootObject) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (rootObject == null) {</span>
<span class="fc" id="L282">            return -1;</span>
        }

<span class="fc" id="L285">        init();</span>

<span class="fc" id="L287">        Object currentObject = rootObject;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L289">            currentObject = segments[i].eval(this, rootObject, currentObject);</span>
        }

<span class="fc" id="L292">        return evalSize(currentObject);</span>
    }

    /**
     * Extract keySet or field names from rootObject on this JSONPath.
     * 
     * @param rootObject Can be a map or custom object. Array and Collection are not supported.
     * @return Set of keys, or &lt;code&gt;null&lt;/code&gt; if not supported.
     */
    public Set&lt;?&gt; keySet(Object rootObject) {
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (rootObject == null) {</span>
<span class="nc" id="L303">            return null;</span>
        }

<span class="fc" id="L306">        init();</span>

<span class="fc" id="L308">        Object currentObject = rootObject;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L310">            currentObject = segments[i].eval(this, rootObject, currentObject);</span>
        }

<span class="fc" id="L313">        return evalKeySet(currentObject);</span>
    }

    public void patchAdd(Object rootObject, Object value, boolean replace) {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (rootObject == null) {</span>
<span class="nc" id="L318">            return;</span>
        }

<span class="fc" id="L321">        init();</span>

<span class="fc" id="L323">        Object currentObject = rootObject;</span>
<span class="fc" id="L324">        Object parentObject = null;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L326">            parentObject = currentObject;</span>
<span class="fc" id="L327">            Segment segment = segments[i];</span>
<span class="fc" id="L328">            currentObject = segment.eval(this, rootObject, currentObject);</span>
<span class="fc bfc" id="L329" title="All 4 branches covered.">            if (currentObject == null &amp;&amp; i != segments.length - 1) {</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">                if (segment instanceof PropertySegment) {</span>
<span class="fc" id="L331">                    currentObject = new JSONObject();</span>
<span class="fc" id="L332">                    ((PropertySegment) segment).setValue(this, parentObject, currentObject);</span>
                }
            }
        }

<span class="fc" id="L337">        Object result = currentObject;</span>

<span class="pc bpc" id="L339" title="1 of 4 branches missed.">        if ((!replace) &amp;&amp; result instanceof Collection) {</span>
<span class="nc" id="L340">            Collection collection = (Collection) result;</span>
<span class="nc" id="L341">            collection.add(value);</span>
<span class="nc" id="L342">            return;</span>
        }

        Object newResult;

<span class="pc bpc" id="L347" title="1 of 4 branches missed.">        if (result != null &amp;&amp; !replace) {</span>
<span class="nc" id="L348">            Class&lt;?&gt; resultClass = result.getClass();</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (resultClass.isArray()) {</span>
<span class="nc" id="L351">                int length = Array.getLength(result);</span>
<span class="nc" id="L352">                Object descArray = Array.newInstance(resultClass.getComponentType(), length + 1);</span>

<span class="nc" id="L354">                System.arraycopy(result, 0, descArray, 0, length);</span>
<span class="nc" id="L355">                Array.set(descArray, length, value);</span>
<span class="nc" id="L356">                newResult = descArray;</span>
<span class="nc" id="L357">            }</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            else if (Map.class.isAssignableFrom(resultClass)) {</span>
<span class="nc" id="L359">                newResult = value;</span>
            } else {
<span class="nc" id="L361">                throw new JSONException(&quot;unsupported array put operation. &quot; + resultClass);</span>
            }
<span class="nc" id="L363">        } else {</span>
<span class="fc" id="L364">            newResult = value;</span>
        }

<span class="fc" id="L367">        Segment lastSegment = segments[segments.length - 1];</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (lastSegment instanceof PropertySegment) {</span>
<span class="fc" id="L369">            PropertySegment propertySegment = (PropertySegment) lastSegment;</span>
<span class="fc" id="L370">            propertySegment.setValue(this, parentObject, newResult);</span>
<span class="fc" id="L371">            return;</span>
        }

<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (lastSegment instanceof ArrayAccessSegment) {</span>
<span class="nc" id="L375">            ((ArrayAccessSegment) lastSegment).setValue(this, parentObject, newResult);</span>
<span class="nc" id="L376">            return;</span>
        }

<span class="nc" id="L379">        throw new UnsupportedOperationException();</span>
    }

    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    public void arrayAdd(Object rootObject, Object... values) {
<span class="fc bfc" id="L384" title="All 4 branches covered.">        if (values == null || values.length == 0) {</span>
<span class="fc" id="L385">            return;</span>
        }

<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (rootObject == null) {</span>
<span class="fc" id="L389">            return;</span>
        }

<span class="fc" id="L392">        init();</span>

<span class="fc" id="L394">        Object currentObject = rootObject;</span>
<span class="fc" id="L395">        Object parentObject = null;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            if (i == segments.length - 1) {</span>
<span class="fc" id="L398">                parentObject = currentObject;</span>
            }
<span class="fc" id="L400">            currentObject = segments[i].eval(this, rootObject, currentObject);</span>
        }

<span class="fc" id="L403">        Object result = currentObject;</span>

<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L406">            throw new JSONPathException(&quot;value not found in path &quot; + path);</span>
        }

<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (result instanceof Collection) {</span>
<span class="fc" id="L410">            Collection collection = (Collection) result;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">            for (Object value : values) {</span>
<span class="fc" id="L412">                collection.add(value);</span>
            }
<span class="fc" id="L414">            return;</span>
        }

<span class="fc" id="L417">        Class&lt;?&gt; resultClass = result.getClass();</span>

        Object newResult;
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (resultClass.isArray()) {</span>
<span class="fc" id="L421">            int length = Array.getLength(result);</span>
<span class="fc" id="L422">            Object descArray = Array.newInstance(resultClass.getComponentType(), length + values.length);</span>

<span class="fc" id="L424">            System.arraycopy(result, 0, descArray, 0, length);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">            for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L426">                Array.set(descArray, length + i, values[i]);</span>

            }
<span class="fc" id="L429">            newResult = descArray;</span>
<span class="fc" id="L430">        } else {</span>
<span class="fc" id="L431">            throw new JSONException(&quot;unsupported array put operation. &quot; + resultClass);</span>
        }

<span class="fc" id="L434">        Segment lastSegment = segments[segments.length - 1];</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (lastSegment instanceof PropertySegment) {</span>
<span class="fc" id="L436">            PropertySegment propertySegment = (PropertySegment) lastSegment;</span>
<span class="fc" id="L437">            propertySegment.setValue(this, parentObject, newResult);</span>
<span class="fc" id="L438">            return;</span>
        }

<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (lastSegment instanceof ArrayAccessSegment) {</span>
<span class="fc" id="L442">            ((ArrayAccessSegment) lastSegment).setValue(this, parentObject, newResult);</span>
<span class="fc" id="L443">            return;</span>
        }

<span class="nc" id="L446">        throw new UnsupportedOperationException();</span>
    }
    
    public boolean remove(Object rootObject) {
<span class="fc bfc" id="L450" title="All 2 branches covered.">        if (rootObject == null) {</span>
<span class="fc" id="L451">            return false;</span>
        }

<span class="fc" id="L454">        init();</span>

<span class="fc" id="L456">        Object currentObject = rootObject;</span>
<span class="fc" id="L457">        Object parentObject = null;</span>

<span class="fc" id="L459">        Segment lastSegment = segments[segments.length - 1];</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            if (i == segments.length - 1) {</span>
<span class="fc" id="L462">                parentObject = currentObject;</span>
<span class="fc" id="L463">                break;</span>
            }
<span class="fc" id="L465">            Segment segement = segments[i];</span>
<span class="pc bpc" id="L466" title="1 of 6 branches missed.">            if (i == segments.length - 2</span>
                    &amp;&amp; lastSegment instanceof FilterSegment
                    &amp;&amp; segement instanceof PropertySegment
            ) {
<span class="fc" id="L470">                FilterSegment filterSegment = (FilterSegment) lastSegment;</span>

<span class="fc bfc" id="L472" title="All 2 branches covered.">                if (currentObject instanceof List) {</span>
<span class="fc" id="L473">                    PropertySegment propertySegment = (PropertySegment) segement;</span>
<span class="fc" id="L474">                    List list = (List) currentObject;</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">                    for (Iterator it = list.iterator();it.hasNext();) {</span>
<span class="fc" id="L477">                        Object item = it.next();</span>
<span class="fc" id="L478">                        Object result = propertySegment.eval(this, rootObject, item);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">                        if (result instanceof Iterable) {</span>
<span class="fc" id="L480">                            filterSegment.remove(this, rootObject, result);</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                        } else if (result instanceof Map) {</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                            if (filterSegment.filter.apply(this, rootObject, currentObject, result)) {</span>
<span class="fc" id="L483">                                it.remove();</span>
                            }
                        }
<span class="fc" id="L486">                    }</span>
<span class="fc" id="L487">                    return true;</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                } else if (currentObject instanceof Map) {</span>
<span class="fc" id="L489">                    PropertySegment propertySegment = (PropertySegment) segement;</span>
<span class="fc" id="L490">                    Object result = propertySegment.eval(this, rootObject, currentObject);</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">                    if (result == null) {</span>
<span class="nc" id="L492">                        return false;</span>
                    }
<span class="fc bfc" id="L494" title="All 2 branches covered.">                    if (result instanceof Map</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">                            &amp;&amp; filterSegment.filter.apply(this, rootObject, currentObject, result)) {</span>
<span class="fc" id="L496">                        propertySegment.remove(this, currentObject);</span>
<span class="fc" id="L497">                        return true;</span>
                    }
                }
            }

<span class="fc" id="L502">            currentObject = segement.eval(this, rootObject, currentObject);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">            if (currentObject == null) {</span>
<span class="fc" id="L504">                break;</span>
            }
        }

<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (parentObject == null) {</span>
<span class="fc" id="L509">            return false;</span>
        }


<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (lastSegment instanceof PropertySegment) {</span>
<span class="fc" id="L514">            PropertySegment propertySegment = (PropertySegment) lastSegment;</span>

<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (parentObject instanceof Collection) {</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                if (segments.length &gt; 1) {</span>
<span class="fc" id="L518">                    Segment parentSegment = segments[segments.length - 2];</span>
<span class="pc bpc" id="L519" title="1 of 4 branches missed.">                    if (parentSegment instanceof RangeSegment || parentSegment instanceof MultiIndexSegment) {</span>
<span class="fc" id="L520">                        Collection collection = (Collection) parentObject;</span>
<span class="fc" id="L521">                        boolean removedOnce = false;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">                        for (Object item : collection) {</span>
<span class="fc" id="L523">                            boolean removed = propertySegment.remove(this, item);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                            if (removed) {</span>
<span class="fc" id="L525">                                removedOnce = true;</span>
                            }
<span class="fc" id="L527">                        }</span>
<span class="fc" id="L528">                        return removedOnce;</span>
                    }
                }
            }
<span class="fc" id="L532">            return propertySegment.remove(this, parentObject);</span>
        }

<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (lastSegment instanceof ArrayAccessSegment) {</span>
<span class="fc" id="L536">            return ((ArrayAccessSegment) lastSegment).remove(this, parentObject);</span>
        }

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (lastSegment instanceof FilterSegment) {</span>
<span class="fc" id="L540">            FilterSegment filterSegment = (FilterSegment) lastSegment;</span>
<span class="fc" id="L541">            return filterSegment.remove(this, rootObject, parentObject);</span>
        }

<span class="nc" id="L544">        throw new UnsupportedOperationException();</span>
    }

    public boolean set(Object rootObject, Object value) {
<span class="fc" id="L548">        return set(rootObject, value, true);</span>
    }

    public boolean set(Object rootObject, Object value, boolean p) {
<span class="fc bfc" id="L552" title="All 2 branches covered.">        if (rootObject == null) {</span>
<span class="fc" id="L553">            return false;</span>
        }

<span class="fc" id="L556">        init();</span>

<span class="fc" id="L558">        Object currentObject = rootObject;</span>
<span class="fc" id="L559">        Object parentObject = null;</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
//            if (i == segments.length - 1) {
//                parentObject = currentObject;
//                break;
//            }
//            
<span class="fc" id="L566">            parentObject = currentObject;</span>
<span class="fc" id="L567">            Segment segment = segments[i];</span>
<span class="fc" id="L568">            currentObject = segment.eval(this, rootObject, currentObject);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            if (currentObject == null) {</span>
<span class="fc" id="L570">                Segment nextSegment = null;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                if (i &lt; segments.length - 1) {</span>
<span class="fc" id="L572">                    nextSegment = segments[i + 1];</span>
                }

<span class="fc" id="L575">                Object newObj = null;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                if (nextSegment instanceof PropertySegment) {</span>
<span class="fc" id="L577">                    JavaBeanDeserializer beanDeserializer = null;</span>
<span class="fc" id="L578">                    Class&lt;?&gt; fieldClass = null;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">                    if (segment instanceof PropertySegment) {</span>
<span class="fc" id="L580">                        String propertyName = ((PropertySegment) segment).propertyName;</span>
<span class="fc" id="L581">                        Class&lt;?&gt; parentClass = parentObject.getClass();</span>
<span class="fc" id="L582">                        JavaBeanDeserializer parentBeanDeserializer = getJavaBeanDeserializer(parentClass);</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                        if (parentBeanDeserializer != null) {</span>
<span class="fc" id="L584">                            FieldDeserializer fieldDeserializer = parentBeanDeserializer.getFieldDeserializer(propertyName);</span>
<span class="fc" id="L585">                            fieldClass = fieldDeserializer.fieldInfo.fieldClass;</span>
<span class="fc" id="L586">                            beanDeserializer = getJavaBeanDeserializer(fieldClass);</span>
                        }
                    }

<span class="fc bfc" id="L590" title="All 2 branches covered.">                    if (beanDeserializer != null) {</span>

<span class="pc bpc" id="L592" title="1 of 2 branches missed.">                        if (beanDeserializer.beanInfo.defaultConstructor != null) {</span>
<span class="fc" id="L593">                            newObj = beanDeserializer.createInstance(null, fieldClass);</span>
                        } else {
<span class="nc" id="L595">                            return false;</span>
                        }
                    } else {
<span class="fc" id="L598">                        newObj = new JSONObject();</span>
                    }
<span class="fc bfc" id="L600" title="All 2 branches covered.">                } else if (nextSegment instanceof ArrayAccessSegment) {</span>
<span class="fc" id="L601">                    newObj = new JSONArray();</span>
                }
                
<span class="fc bfc" id="L604" title="All 2 branches covered.">                if (newObj != null) {</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                    if (segment instanceof PropertySegment) {</span>
<span class="fc" id="L606">                        PropertySegment propSegement = (PropertySegment) segment;</span>
<span class="fc" id="L607">                        propSegement.setValue(this, parentObject, newObj);</span>
<span class="fc" id="L608">                        currentObject = newObj;</span>
<span class="fc" id="L609">                        continue;</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">                    } else if (segment instanceof ArrayAccessSegment) {</span>
<span class="fc" id="L611">                        ArrayAccessSegment arrayAccessSegement = (ArrayAccessSegment) segment;</span>
<span class="fc" id="L612">                        arrayAccessSegement.setValue(this, parentObject, newObj);</span>
<span class="fc" id="L613">                        currentObject = newObj;</span>
<span class="fc" id="L614">                        continue;</span>
                    }
                }
                
                break;
            }
        }

<span class="pc bpc" id="L622" title="1 of 2 branches missed.">        if (parentObject == null) {</span>
<span class="nc" id="L623">            return false;</span>
        }

<span class="fc" id="L626">        Segment lastSegment = segments[segments.length - 1];</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (lastSegment instanceof PropertySegment) {</span>
<span class="fc" id="L628">            PropertySegment propertySegment = (PropertySegment) lastSegment;</span>
<span class="fc" id="L629">            propertySegment.setValue(this, parentObject, value);</span>
<span class="fc" id="L630">            return true;</span>
        }

<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        if (lastSegment instanceof ArrayAccessSegment) {</span>
<span class="fc" id="L634">            return ((ArrayAccessSegment) lastSegment).setValue(this, parentObject, value);</span>
        }

<span class="nc" id="L637">        throw new UnsupportedOperationException();</span>
    }

    public static Object eval(Object rootObject, String path) {
<span class="fc" id="L641">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L642">        return jsonpath.eval(rootObject);</span>
    }

    public static Object eval(Object rootObject, String path, boolean ignoreNullValue) {
<span class="nc" id="L646">        JSONPath jsonpath = compile(path, ignoreNullValue);</span>
<span class="nc" id="L647">        return jsonpath.eval(rootObject);</span>
    }

    public static int size(Object rootObject, String path) {
<span class="fc" id="L651">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L652">        Object result = jsonpath.eval(rootObject);</span>
<span class="fc" id="L653">        return jsonpath.evalSize(result);</span>
    }

    /**
     * Compile jsonPath and use it to extract keySet or field names from rootObject.
     * 
     * @param rootObject Can be a map or custom object. Array and Collection are not supported.
     * @param path JSONPath string to be compiled.
     * @return Set of keys, or &lt;code&gt;null&lt;/code&gt; if not supported.
     */
    public static Set&lt;?&gt; keySet(Object rootObject, String path) {
<span class="fc" id="L664">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L665">        Object result = jsonpath.eval(rootObject);</span>
<span class="fc" id="L666">        return jsonpath.evalKeySet(result);</span>
    }

    public static boolean contains(Object rootObject, String path) {
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (rootObject == null) {</span>
<span class="fc" id="L671">            return false;</span>
        }

<span class="fc" id="L674">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L675">        return jsonpath.contains(rootObject);</span>
    }

    public static boolean containsValue(Object rootObject, String path, Object value) {
<span class="fc" id="L679">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L680">        return jsonpath.containsValue(rootObject, value);</span>
    }

    public static void arrayAdd(Object rootObject, String path, Object... values) {
<span class="fc" id="L684">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L685">        jsonpath.arrayAdd(rootObject, values);</span>
<span class="fc" id="L686">    }</span>

    public static boolean set(Object rootObject, String path, Object value) {
<span class="fc" id="L689">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L690">        return jsonpath.set(rootObject, value);</span>
    }
    
    public static boolean remove(Object root, String path) {
<span class="fc" id="L694">        JSONPath jsonpath = compile(path);</span>
<span class="fc" id="L695">        return jsonpath.remove(root);</span>
    }

    public static JSONPath compile(String path) {
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (path == null) {</span>
<span class="fc" id="L700">            throw new JSONPathException(&quot;jsonpath can not be null&quot;);</span>
        }
        
<span class="fc" id="L703">        JSONPath jsonpath = pathCache.get(path);</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (jsonpath == null) {</span>
<span class="fc" id="L705">            jsonpath = new JSONPath(path);</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">            if (pathCache.size() &lt; 1024) {</span>
<span class="fc" id="L707">                pathCache.putIfAbsent(path, jsonpath);</span>
<span class="fc" id="L708">                jsonpath = pathCache.get(path);</span>
            }
        }
<span class="fc" id="L711">        return jsonpath;</span>
    }

    public static JSONPath compile(String path, boolean ignoreNullValue) {
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (path == null) {</span>
<span class="nc" id="L716">            throw new JSONPathException(&quot;jsonpath can not be null&quot;);</span>
        }

<span class="nc" id="L719">        JSONPath jsonpath = pathCache.get(path);</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (jsonpath == null) {</span>
<span class="nc" id="L721">            jsonpath = new JSONPath(path, ignoreNullValue);</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">            if (pathCache.size() &lt; 1024) {</span>
<span class="nc" id="L723">                pathCache.putIfAbsent(path, jsonpath);</span>
<span class="nc" id="L724">                jsonpath = pathCache.get(path);</span>
            }
        }
<span class="nc" id="L727">        return jsonpath;</span>
    }

    /**
     * @since 1.2.9
     * @param json
     * @param path
     * @return
     */
    public static Object read(String json, String path) {
<span class="fc" id="L737">        return compile(path)</span>
<span class="fc" id="L738">                .eval(</span>
<span class="fc" id="L739">                        JSON.parse(json)</span>
                );
    }
    
    /**
     * @since 1.2.76
     * @param json
     * @param path
     * @param clazz
     * @param parserConfig
     * @return
     */
    public static &lt;T&gt; T read(String json, String path, Type clazz, ParserConfig parserConfig) {
<span class="nc" id="L752">        return compile(path).eval(JSON.parse(json), clazz, parserConfig);</span>
    }
    
    /**
     * @since 1.2.76
     * @param json
     * @param path
     * @param clazz
     * @return
     */
    public static &lt;T&gt; T read(String json, String path, Type clazz) {
<span class="nc" id="L763">        return read(json, path, clazz, null);</span>
    }

    /**
     * @since 1.2.51
     * @param json
     * @param path
     * @return
     */
    public static Object extract(String json, String path, ParserConfig config, int features, Feature... optionFeatures) {
<span class="fc" id="L773">        features |= Feature.OrderedField.mask;</span>
<span class="fc" id="L774">        DefaultJSONParser parser = new DefaultJSONParser(json, config, features);</span>
<span class="fc" id="L775">        JSONPath jsonPath = compile(path);</span>
<span class="fc" id="L776">        Object result = jsonPath.extract(parser);</span>
<span class="fc" id="L777">        parser.lexer.close();</span>
<span class="fc" id="L778">        return result;</span>
    }

    public static Object extract(String json, String path) {
<span class="fc" id="L782">        return extract(json, path, ParserConfig.global, JSON.DEFAULT_PARSER_FEATURE);</span>
    }

    public static Map&lt;String, Object&gt; paths(Object javaObject) {
<span class="fc" id="L786">        return paths(javaObject, SerializeConfig.globalInstance);</span>
    }
    
    public static Map&lt;String, Object&gt; paths(Object javaObject, SerializeConfig config) {
<span class="fc" id="L790">        Map&lt;Object, String&gt; values = new IdentityHashMap&lt;Object, String&gt;();</span>
<span class="fc" id="L791">        Map&lt;String, Object&gt; paths = new HashMap&lt;String, Object&gt;();</span>

<span class="fc" id="L793">        paths(values, paths, &quot;/&quot;, javaObject, config);</span>
<span class="fc" id="L794">        return paths;</span>
    }

    private static void paths(Map&lt;Object, String&gt; values, Map&lt;String, Object&gt; paths, String parent, Object javaObject, SerializeConfig config) {
<span class="fc bfc" id="L798" title="All 2 branches covered.">        if (javaObject == null) {</span>
<span class="fc" id="L799">            return;</span>
        }

<span class="fc" id="L802">        String p = values.put(javaObject, parent);</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (p != null) {</span>
<span class="fc" id="L804">            Class&lt;?&gt; type = javaObject.getClass();</span>
<span class="pc bpc" id="L805" title="5 of 8 branches missed.">            boolean basicType =  type == String.class</span>
                    || type == Boolean.class
                    || type == Character.class
                    || type == UUID.class
<span class="pc bnc" id="L809" title="All 6 branches missed.">                    || type.isEnum()</span>
                    || javaObject instanceof Number
                    || javaObject instanceof Date
                    ;

<span class="pc bpc" id="L814" title="1 of 2 branches missed.">            if (!basicType) {</span>
<span class="nc" id="L815">                return;</span>
            }
        }

<span class="fc" id="L819">        paths.put(parent, javaObject);</span>

<span class="fc bfc" id="L821" title="All 2 branches covered.">        if (javaObject instanceof Map) {</span>
<span class="fc" id="L822">            Map map = (Map) javaObject;</span>

<span class="fc bfc" id="L824" title="All 2 branches covered.">            for (Object entryObj : map.entrySet()) {</span>
<span class="fc" id="L825">                Map.Entry entry = (Map.Entry) entryObj;</span>
<span class="fc" id="L826">                Object key = entry.getKey();</span>

<span class="pc bpc" id="L828" title="1 of 2 branches missed.">                if (key instanceof String) {</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">                    String path = parent.equals(&quot;/&quot;) ?  &quot;/&quot; + key : parent + &quot;/&quot; + key;</span>
<span class="fc" id="L830">                    paths(values, paths, path, entry.getValue(), config);</span>
                }
<span class="fc" id="L832">            }</span>
<span class="fc" id="L833">            return;</span>
        }

<span class="fc bfc" id="L836" title="All 2 branches covered.">        if (javaObject instanceof Collection) {</span>
<span class="fc" id="L837">            Collection collection = (Collection) javaObject;</span>

<span class="fc" id="L839">            int i = 0;</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">            for (Object item : collection) {</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">                String path = parent.equals(&quot;/&quot;) ?  &quot;/&quot; + i : parent + &quot;/&quot; + i;</span>
<span class="fc" id="L842">                paths(values, paths, path, item, config);</span>
<span class="fc" id="L843">                ++i;</span>
<span class="fc" id="L844">            }</span>

<span class="fc" id="L846">            return;</span>
        }

<span class="fc" id="L849">        Class&lt;?&gt; clazz = javaObject.getClass();</span>

<span class="fc bfc" id="L851" title="All 2 branches covered.">        if (clazz.isArray()) {</span>
<span class="fc" id="L852">            int len = Array.getLength(javaObject);</span>

<span class="fc bfc" id="L854" title="All 2 branches covered.">            for (int i = 0; i &lt; len; ++i) {</span>
<span class="fc" id="L855">                Object item = Array.get(javaObject, i);</span>

<span class="pc bpc" id="L857" title="1 of 2 branches missed.">                String path = parent.equals(&quot;/&quot;) ?  &quot;/&quot; + i : parent + &quot;/&quot; + i;</span>
<span class="fc" id="L858">                paths(values, paths, path, item, config);</span>
            }

<span class="fc" id="L861">            return;</span>
        }

<span class="pc bpc" id="L864" title="1 of 4 branches missed.">        if (ParserConfig.isPrimitive2(clazz) || clazz.isEnum()) {</span>
<span class="fc" id="L865">            return;</span>
        }

<span class="fc" id="L868">        ObjectSerializer serializer = config.getObjectWriter(clazz);</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">        if (serializer instanceof JavaBeanSerializer) {</span>
<span class="fc" id="L870">            JavaBeanSerializer javaBeanSerializer = (JavaBeanSerializer) serializer;</span>

            try {
<span class="fc" id="L873">                Map&lt;String, Object&gt; fieldValues = javaBeanSerializer.getFieldValuesMap(javaObject);</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">                for (Map.Entry&lt;String, Object&gt; entry : fieldValues.entrySet()) {</span>
<span class="fc" id="L875">                    String key = entry.getKey();</span>

<span class="pc bpc" id="L877" title="1 of 2 branches missed.">                    if (key instanceof String) {</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">                        String path = parent.equals(&quot;/&quot;) ?  &quot;/&quot; + key : parent + &quot;/&quot; + key;</span>
<span class="fc" id="L879">                        paths(values, paths, path, entry.getValue(), config);</span>
                    }
<span class="fc" id="L881">                }</span>
<span class="fc" id="L882">            } catch (Exception e) {</span>
<span class="fc" id="L883">                throw new JSONException(&quot;toJSON error&quot;, e);</span>
<span class="fc" id="L884">            }</span>
<span class="fc" id="L885">            return;</span>
        }

<span class="fc" id="L888">        return;</span>
    }

    public String getPath() {
<span class="fc" id="L892">        return path;</span>
    }

    static class JSONPathParser {

        private final String path;
        private int          pos;
        private char         ch;
        private int          level;
        private boolean      hasRefSegment;
        private static final String strArrayRegex = &quot;\'\\s*,\\s*\'&quot;;
<span class="fc" id="L903">        private static final Pattern strArrayPatternx = Pattern.compile(strArrayRegex);</span>

<span class="fc" id="L905">        public JSONPathParser(String path){</span>
<span class="fc" id="L906">            this.path = path;</span>
<span class="fc" id="L907">            next();</span>
<span class="fc" id="L908">        }</span>

        void next() {
<span class="fc" id="L911">            ch = path.charAt(pos++);</span>
<span class="fc" id="L912">        }</span>

        char getNextChar() {
<span class="fc" id="L915">            return path.charAt(pos);</span>
        }

        boolean isEOF() {
<span class="fc bfc" id="L919" title="All 2 branches covered.">            return pos &gt;= path.length();</span>
        }

        Segment readSegement() {
<span class="fc bfc" id="L923" title="All 4 branches covered.">            if (level == 0 &amp;&amp; path.length() == 1) {</span>
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">                if (isDigitFirst(ch)) {</span>
<span class="nc" id="L925">                    int index = ch - '0';</span>
<span class="nc" id="L926">                    return new ArrayAccessSegment(index);</span>
<span class="pc bpc" id="L927" title="6 of 8 branches missed.">                } else if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || ((ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z'))) {</span>
<span class="nc" id="L928">                    return new PropertySegment(Character.toString(ch), false);</span>
                }
            }
<span class="fc bfc" id="L931" title="All 2 branches covered.">            while (!isEOF()) {</span>
<span class="fc" id="L932">                skipWhitespace();</span>

<span class="fc bfc" id="L934" title="All 2 branches covered.">                if (ch == '$') {</span>
<span class="fc" id="L935">                    next();</span>
<span class="fc" id="L936">                    skipWhitespace();</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">                    if (ch == '?') {</span>
<span class="fc" id="L938">                        return new FilterSegment(</span>
<span class="fc" id="L939">                                (Filter) parseArrayAccessFilter(false));</span>
                    }
                    continue;
                }

<span class="fc bfc" id="L944" title="All 4 branches covered.">                if (ch == '.' || ch == '/') {</span>
<span class="fc" id="L945">                    int c0 = ch;</span>
<span class="fc" id="L946">                    boolean deep = false;</span>
<span class="fc" id="L947">                    next();</span>
<span class="fc bfc" id="L948" title="All 4 branches covered.">                    if (c0 == '.' &amp;&amp; ch == '.') {</span>
<span class="fc" id="L949">                        next();</span>
<span class="fc" id="L950">                        deep = true;</span>
<span class="fc bfc" id="L951" title="All 4 branches covered.">                        if (path.length() &gt; pos + 3</span>
                                &amp;&amp; ch == '['
<span class="fc bfc" id="L953" title="All 2 branches covered.">                                &amp;&amp; path.charAt(pos) == '*'</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">                                &amp;&amp; path.charAt(pos + 1) == ']'</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">                                &amp;&amp; path.charAt(pos + 2) == '.') {</span>
<span class="fc" id="L956">                            next();</span>
<span class="fc" id="L957">                            next();</span>
<span class="fc" id="L958">                            next();</span>
<span class="fc" id="L959">                            next();</span>
                        }
                    }
<span class="fc bfc" id="L962" title="All 6 branches covered.">                    if (ch == '*' || (deep &amp;&amp; ch == '[')) {</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">                        boolean objectOnly = ch == '[';</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">                        if (!isEOF()) {</span>
<span class="fc" id="L965">                            next();</span>
                        }

<span class="fc bfc" id="L968" title="All 2 branches covered.">                        if (deep) {</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">                            if (objectOnly) {</span>
<span class="fc" id="L970">                                return WildCardSegment.instance_deep_objectOnly;</span>
                            } else {
<span class="fc" id="L972">                                return WildCardSegment.instance_deep;</span>
                            }
                        } else {
<span class="fc" id="L975">                            return WildCardSegment.instance;</span>
                        }
                    }
                    
<span class="fc bfc" id="L979" title="All 2 branches covered.">                    if (isDigitFirst(ch)) {</span>
<span class="fc" id="L980">                        return parseArrayAccess(false);</span>
                    }

<span class="fc" id="L983">                    String propertyName = readName();</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">                    if (ch == '(') {</span>
<span class="fc" id="L985">                        next();</span>
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">                        if (ch == ')') {</span>
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">                            if (!isEOF()) {</span>
<span class="nc" id="L988">                                next();</span>
                            }

<span class="fc bfc" id="L991" title="All 4 branches covered.">                            if (&quot;size&quot;.equals(propertyName) || &quot;length&quot;.equals(propertyName)) {</span>
<span class="fc" id="L992">                                return SizeSegment.instance;</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">                            } else if (&quot;max&quot;.equals(propertyName)) {</span>
<span class="fc" id="L994">                                return MaxSegment.instance;</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">                            } else if (&quot;min&quot;.equals(propertyName)) {</span>
<span class="fc" id="L996">                                return MinSegment.instance;</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">                            } else if (&quot;keySet&quot;.equals(propertyName)) {</span>
<span class="fc" id="L998">                                return KeySetSegment.instance;</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">                            } else if (&quot;type&quot;.equals(propertyName)) {</span>
<span class="fc" id="L1000">                                return TypeSegment.instance;</span>
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">                            } else if (&quot;floor&quot;.equals(propertyName)) {</span>
<span class="fc" id="L1002">                                return FloorSegment.instance;</span>
                            }

<span class="nc" id="L1005">                            throw new JSONPathException(&quot;not support jsonpath : &quot; + path);</span>
                        }

<span class="nc" id="L1008">                        throw new JSONPathException(&quot;not support jsonpath : &quot; + path);</span>
                    }

<span class="fc" id="L1011">                    return new PropertySegment(propertyName, deep);</span>
                }

<span class="fc bfc" id="L1014" title="All 2 branches covered.">                if (ch == '[') {</span>
<span class="fc" id="L1015">                    return parseArrayAccess(true);</span>
                }

<span class="fc bfc" id="L1018" title="All 2 branches covered.">                if (level == 0) {</span>
<span class="fc" id="L1019">                    String propertyName = readName();</span>

<span class="fc" id="L1021">                    return new PropertySegment(propertyName, false);</span>
                }

<span class="fc bfc" id="L1024" title="All 2 branches covered.">                if (ch == '?') {</span>
<span class="fc" id="L1025">                    return new FilterSegment(</span>
<span class="fc" id="L1026">                            (Filter) parseArrayAccessFilter(false));</span>
                }

<span class="fc" id="L1029">                throw new JSONPathException(&quot;not support jsonpath : &quot; + path);</span>
            }

<span class="fc" id="L1032">            return null;</span>
        }

        public final void skipWhitespace() {
            for (;;) {
<span class="pc bpc" id="L1037" title="11 of 14 branches missed.">                if (ch &lt;= ' ' &amp;&amp; (ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t' || ch == '\f' || ch == '\b')) {</span>
<span class="fc" id="L1038">                    next();</span>
<span class="fc" id="L1039">                    continue;</span>
                } else {
                    break;
                }
            }
<span class="fc" id="L1044">        }</span>

        Segment parseArrayAccess(boolean acceptBracket) {
<span class="fc" id="L1047">            Object object = parseArrayAccessFilter(acceptBracket);</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            if (object instanceof Segment) {</span>
<span class="fc" id="L1049">                return ((Segment) object);</span>
            }
<span class="fc" id="L1051">            return new FilterSegment((Filter) object);</span>
        }

        Object parseArrayAccessFilter(boolean acceptBracket) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (acceptBracket) {</span>
<span class="fc" id="L1056">                accept('[');</span>
            }

<span class="fc" id="L1059">            boolean predicateFlag = false;</span>
<span class="fc" id="L1060">            int lparanCount = 0;</span>

<span class="fc bfc" id="L1062" title="All 2 branches covered.">            if (ch == '?') {</span>
<span class="fc" id="L1063">                next();</span>
<span class="fc" id="L1064">                accept('(');</span>
<span class="fc" id="L1065">                lparanCount++;</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">                while (ch == '(') {</span>
<span class="fc" id="L1067">                    next();</span>
<span class="fc" id="L1068">                    lparanCount++;</span>
                }
<span class="fc" id="L1070">                predicateFlag = true;</span>
            }

<span class="fc" id="L1073">            skipWhitespace();</span>

<span class="fc bfc" id="L1075" title="All 2 branches covered.">            if (predicateFlag</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">                    || IOUtils.firstIdentifier(ch)</span>
<span class="fc bfc" id="L1077" title="All 6 branches covered.">                    || Character.isJavaIdentifierStart(ch)</span>
                    || ch == '\\'
                    || ch == '@') {
<span class="fc" id="L1080">                boolean self = false;</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">                if (ch == '@') {</span>
<span class="fc" id="L1082">                    next();</span>
<span class="fc" id="L1083">                    accept('.');</span>
<span class="fc" id="L1084">                    self = true;</span>
                }
<span class="fc" id="L1086">                String propertyName = readName();</span>

<span class="fc" id="L1088">                skipWhitespace();</span>

<span class="fc bfc" id="L1090" title="All 4 branches covered.">                if (predicateFlag &amp;&amp; ch == ')') {</span>
<span class="fc" id="L1091">                    next();</span>

<span class="fc" id="L1093">                    Filter filter = new NotNullSegement(propertyName, false);</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">                    while (ch == ' ') {</span>
<span class="nc" id="L1095">                        next();</span>
                    }

<span class="pc bpc" id="L1098" title="2 of 4 branches missed.">                    if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1099">                        filter = filterRest(filter);</span>
                    }

<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">                    if (acceptBracket) {</span>
<span class="fc" id="L1103">                        accept(']');</span>
                    }
<span class="fc" id="L1105">                    return filter;</span>
                }

<span class="fc bfc" id="L1108" title="All 4 branches covered.">                if (acceptBracket &amp;&amp; ch == ']') {</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">                    if (isEOF()) {</span>
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">                        if (propertyName.equals(&quot;last&quot;)) {</span>
<span class="fc" id="L1111">                            return new MultiIndexSegment(new int[]{-1});</span>
                        }
                    }

<span class="nc" id="L1115">                    next();</span>
<span class="nc" id="L1116">                    Filter filter = new NotNullSegement(propertyName, false);</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                    while (ch == ' ') {</span>
<span class="nc" id="L1118">                        next();</span>
                    }

<span class="nc bnc" id="L1121" title="All 4 branches missed.">                    if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1122">                        filter = filterRest(filter);</span>
                    }

<span class="nc" id="L1125">                    accept(')');</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                    if (predicateFlag) {</span>
<span class="nc" id="L1127">                        accept(')');</span>
                    }

<span class="nc bnc" id="L1130" title="All 2 branches missed.">                    if (acceptBracket) {</span>
<span class="nc" id="L1131">                        accept(']');</span>
                    }
<span class="nc" id="L1133">                    return filter;</span>
                }

<span class="fc" id="L1136">                boolean function = false;</span>
<span class="fc" id="L1137">                skipWhitespace();</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">                if (ch == '(') {</span>
<span class="fc" id="L1139">                    next();</span>
<span class="fc" id="L1140">                    accept(')');</span>
<span class="fc" id="L1141">                    skipWhitespace();</span>
<span class="fc" id="L1142">                    function = true;</span>
                }

<span class="fc" id="L1145">                Operator op = readOp();</span>

<span class="fc" id="L1147">                skipWhitespace();</span>

<span class="fc bfc" id="L1149" title="All 4 branches covered.">                if (op == Operator.BETWEEN || op == Operator.NOT_BETWEEN) {</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">                    final boolean not = (op == Operator.NOT_BETWEEN);</span>

<span class="fc" id="L1152">                    Object startValue = readValue();</span>

<span class="fc" id="L1154">                    String name = readName();</span>

<span class="pc bpc" id="L1156" title="1 of 2 branches missed.">                    if (!&quot;and&quot;.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L1157">                        throw new JSONPathException(path);</span>
                    }

<span class="fc" id="L1160">                    Object endValue = readValue();</span>

<span class="pc bpc" id="L1162" title="2 of 4 branches missed.">                    if (startValue == null || endValue == null) {</span>
<span class="nc" id="L1163">                        throw new JSONPathException(path);</span>
                    }

<span class="pc bpc" id="L1166" title="2 of 4 branches missed.">                    if (isInt(startValue.getClass()) &amp;&amp; isInt(endValue.getClass())) {</span>
<span class="fc" id="L1167">                        Filter filter = new IntBetweenSegement(propertyName</span>
                                , function
<span class="fc" id="L1169">                                , TypeUtils.longExtractValue((Number) startValue)</span>
<span class="fc" id="L1170">                                , TypeUtils.longExtractValue((Number) endValue)</span>
                                , not);
<span class="fc" id="L1172">                        return filter;</span>
                    }

<span class="nc" id="L1175">                    throw new JSONPathException(path);</span>
                }

<span class="fc bfc" id="L1178" title="All 4 branches covered.">                if (op == Operator.IN || op == Operator.NOT_IN) {</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">                    final boolean not = (op == Operator.NOT_IN);</span>
<span class="fc" id="L1180">                    accept('(');</span>

<span class="fc" id="L1182">                    List&lt;Object&gt; valueList = new JSONArray();</span>
                    {
<span class="fc" id="L1184">                        Object value = readValue();</span>
<span class="fc" id="L1185">                        valueList.add(value);</span>

                        for (;;) {
<span class="fc" id="L1188">                            skipWhitespace();</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">                            if (ch != ',') {</span>
<span class="fc" id="L1190">                                break;</span>
                            }
<span class="fc" id="L1192">                            next();</span>

<span class="fc" id="L1194">                            value = readValue();</span>
<span class="fc" id="L1195">                            valueList.add(value);</span>
                        }
                    }

<span class="fc" id="L1199">                    boolean isInt = true;</span>
<span class="fc" id="L1200">                    boolean isIntObj = true;</span>
<span class="fc" id="L1201">                    boolean isString = true;</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">                    for (Object item : valueList) {</span>
<span class="fc bfc" id="L1203" title="All 2 branches covered.">                        if (item == null) {</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">                            if (isInt) {</span>
<span class="fc" id="L1205">                                isInt = false;</span>
                            }
                            continue;
                        }

<span class="fc" id="L1210">                        Class&lt;?&gt; clazz = item.getClass();</span>
<span class="pc bpc" id="L1211" title="3 of 10 branches missed.">                        if (isInt &amp;&amp; !(clazz == Byte.class || clazz == Short.class || clazz == Integer.class</span>
                                       || clazz == Long.class)) {
<span class="fc" id="L1213">                            isInt = false;</span>
<span class="fc" id="L1214">                            isIntObj = false;</span>
                        }

<span class="fc bfc" id="L1217" title="All 4 branches covered.">                        if (isString &amp;&amp; clazz != String.class) {</span>
<span class="fc" id="L1218">                            isString = false;</span>
                        }
<span class="fc" id="L1220">                    }</span>

<span class="fc bfc" id="L1222" title="All 4 branches covered.">                    if (valueList.size() == 1 &amp;&amp; valueList.get(0) == null) {</span>
                        Filter filter;
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">                        if (not) {</span>
<span class="fc" id="L1225">                            filter = new NotNullSegement(propertyName, function);</span>
                        } else {
<span class="nc" id="L1227">                            filter = new NullSegement(propertyName, function);</span>
                        }

<span class="pc bpc" id="L1230" title="1 of 2 branches missed.">                        while (ch == ' ') {</span>
<span class="nc" id="L1231">                            next();</span>
                        }

<span class="pc bpc" id="L1234" title="2 of 4 branches missed.">                        if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1235">                            filter = filterRest(filter);</span>
                        }

<span class="fc" id="L1238">                        accept(')');</span>
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">                        if (predicateFlag) {</span>
<span class="nc" id="L1240">                            accept(')');</span>
                        }

<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">                        if (acceptBracket) {</span>
<span class="fc" id="L1244">                            accept(']');</span>
                        }

<span class="fc" id="L1247">                        return filter;</span>
                    }

<span class="fc bfc" id="L1250" title="All 2 branches covered.">                    if (isInt) {</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">                        if (valueList.size() == 1) {</span>
<span class="fc" id="L1252">                            long value = TypeUtils.longExtractValue((Number) valueList.get(0));</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">                            Operator intOp = not ? Operator.NE : Operator.EQ;</span>
<span class="fc" id="L1254">                            Filter filter = new IntOpSegement(propertyName, function, value, intOp);</span>
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">                            while (ch == ' ') {</span>
<span class="nc" id="L1256">                                next();</span>
                            }

<span class="pc bpc" id="L1259" title="2 of 4 branches missed.">                            if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1260">                                filter = filterRest(filter);</span>
                            }

<span class="fc" id="L1263">                            accept(')');</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">                            if (predicateFlag) {</span>
<span class="nc" id="L1265">                                accept(')');</span>
                            }

<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">                            if (acceptBracket) {</span>
<span class="fc" id="L1269">                                accept(']');</span>
                            }

<span class="fc" id="L1272">                            return filter;</span>
                        }

<span class="fc" id="L1275">                        long[] values = new long[valueList.size()];</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">                        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1277">                            values[i] = TypeUtils.longExtractValue((Number) valueList.get(i));</span>
                        }

<span class="fc" id="L1280">                        Filter filter = new IntInSegement(propertyName, function, values, not);</span>

<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">                        while (ch == ' ') {</span>
<span class="nc" id="L1283">                            next();</span>
                        }

<span class="pc bpc" id="L1286" title="2 of 4 branches missed.">                        if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1287">                            filter = filterRest(filter);</span>
                        }

<span class="fc" id="L1290">                        accept(')');</span>
<span class="pc bpc" id="L1291" title="1 of 2 branches missed.">                        if (predicateFlag) {</span>
<span class="nc" id="L1292">                            accept(')');</span>
                        }

<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">                        if (acceptBracket) {</span>
<span class="fc" id="L1296">                            accept(']');</span>
                        }

<span class="fc" id="L1299">                        return filter;</span>
                    }

<span class="fc bfc" id="L1302" title="All 2 branches covered.">                    if (isString) {</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">                        if (valueList.size() == 1) {</span>
<span class="fc" id="L1304">                            String value = (String) valueList.get(0);</span>

<span class="fc bfc" id="L1306" title="All 2 branches covered.">                            Operator intOp = not ? Operator.NE : Operator.EQ;</span>
<span class="fc" id="L1307">                            Filter filter = new StringOpSegement(propertyName, function, value, intOp);</span>

<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">                            while (ch == ' ') {</span>
<span class="nc" id="L1310">                                next();</span>
                            }

<span class="pc bpc" id="L1313" title="2 of 4 branches missed.">                            if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1314">                                filter = filterRest(filter);</span>
                            }

<span class="fc" id="L1317">                            accept(')');</span>
<span class="pc bpc" id="L1318" title="1 of 2 branches missed.">                            if (predicateFlag) {</span>
<span class="nc" id="L1319">                                accept(')');</span>
                            }

<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">                            if (acceptBracket) {</span>
<span class="fc" id="L1323">                                accept(']');</span>
                            }

<span class="fc" id="L1326">                            return filter;</span>
                        }

<span class="fc" id="L1329">                        String[] values = new String[valueList.size()];</span>
<span class="fc" id="L1330">                        valueList.toArray(values);</span>

<span class="fc" id="L1332">                        Filter filter = new StringInSegement(propertyName, function, values, not);</span>

<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">                        while (ch == ' ') {</span>
<span class="nc" id="L1335">                            next();</span>
                        }

<span class="pc bpc" id="L1338" title="2 of 4 branches missed.">                        if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1339">                            filter = filterRest(filter);</span>
                        }

<span class="fc" id="L1342">                        accept(')');</span>
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">                        if (predicateFlag) {</span>
<span class="nc" id="L1344">                            accept(')');</span>
                        }

<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">                        if (acceptBracket) {</span>
<span class="fc" id="L1348">                            accept(']');</span>
                        }

<span class="fc" id="L1351">                        return filter;</span>
                    }

<span class="pc bpc" id="L1354" title="1 of 2 branches missed.">                    if (isIntObj) {</span>
<span class="fc" id="L1355">                        Long[] values = new Long[valueList.size()];</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">                        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="fc" id="L1357">                            Number item = (Number) valueList.get(i);</span>
<span class="fc bfc" id="L1358" title="All 2 branches covered.">                            if (item != null) {</span>
<span class="fc" id="L1359">                                values[i] = TypeUtils.longExtractValue(item);</span>
                            }
                        }

<span class="fc" id="L1363">                        Filter filter = new IntObjInSegement(propertyName, function, values, not);</span>

<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">                        while (ch == ' ') {</span>
<span class="nc" id="L1366">                            next();</span>
                        }

<span class="pc bpc" id="L1369" title="2 of 4 branches missed.">                        if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1370">                            filter = filterRest(filter);</span>
                        }

<span class="fc" id="L1373">                        accept(')');</span>
<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">                        if (predicateFlag) {</span>
<span class="nc" id="L1375">                            accept(')');</span>
                        }

<span class="pc bpc" id="L1378" title="1 of 2 branches missed.">                        if (acceptBracket) {</span>
<span class="fc" id="L1379">                            accept(']');</span>
                        }

<span class="fc" id="L1382">                        return filter;</span>
                    }

<span class="nc" id="L1385">                    throw new UnsupportedOperationException();</span>
                }

<span class="fc bfc" id="L1388" title="All 4 branches covered.">                if (ch == '\'' || ch == '&quot;') {</span>
<span class="fc" id="L1389">                    String strValue = readString();</span>

<span class="fc" id="L1391">                    Filter filter = null;</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">                    if (op == Operator.RLIKE) {</span>
<span class="fc" id="L1393">                        filter = new RlikeSegement(propertyName, function, strValue, false);</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">                    } else if (op == Operator.NOT_RLIKE) {</span>
<span class="fc" id="L1395">                        filter = new RlikeSegement(propertyName, function, strValue, true);</span>
<span class="fc bfc" id="L1396" title="All 4 branches covered.">                    } else  if (op == Operator.LIKE || op == Operator.NOT_LIKE) {</span>
<span class="pc bpc" id="L1397" title="1 of 2 branches missed.">                        while (strValue.indexOf(&quot;%%&quot;) != -1) {</span>
<span class="nc" id="L1398">                            strValue = strValue.replaceAll(&quot;%%&quot;, &quot;%&quot;);</span>
                        }

<span class="fc bfc" id="L1401" title="All 2 branches covered.">                        final boolean not = (op == Operator.NOT_LIKE);</span>

<span class="fc" id="L1403">                        int p0 = strValue.indexOf('%');</span>
<span class="fc bfc" id="L1404" title="All 2 branches covered.">                        if (p0 == -1) {</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">                            if (op == Operator.LIKE) {</span>
<span class="fc" id="L1406">                                op = Operator.EQ;</span>
                            } else {
<span class="fc" id="L1408">                                op = Operator.NE;</span>
                            }
<span class="fc" id="L1410">                            filter = new StringOpSegement(propertyName, function, strValue, op);</span>
                        } else {
<span class="fc" id="L1412">                            String[] items = strValue.split(&quot;%&quot;);</span>

<span class="fc" id="L1414">                            String startsWithValue = null;</span>
<span class="fc" id="L1415">                            String endsWithValue = null;</span>
<span class="fc" id="L1416">                            String[] containsValues = null;</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">                            if (p0 == 0) {</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">                                if (strValue.charAt(strValue.length() - 1) == '%') {</span>
<span class="fc" id="L1419">                                    containsValues = new String[items.length - 1];</span>
<span class="fc" id="L1420">                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);</span>
                                } else {
<span class="fc" id="L1422">                                    endsWithValue = items[items.length - 1];</span>
<span class="pc bpc" id="L1423" title="1 of 2 branches missed.">                                    if (items.length &gt; 2) {</span>
<span class="nc" id="L1424">                                        containsValues = new String[items.length - 2];</span>
<span class="nc" id="L1425">                                        System.arraycopy(items, 1, containsValues, 0, containsValues.length);</span>
                                    }
                                }
<span class="fc bfc" id="L1428" title="All 2 branches covered.">                            } else if (strValue.charAt(strValue.length() - 1) == '%') {</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">                                if (items.length == 1) {</span>
<span class="fc" id="L1430">                                    startsWithValue = items[0];</span>
                                } else {
<span class="nc" id="L1432">                                    containsValues = items;</span>
                                }
                            } else {
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">                                if (items.length == 1) {</span>
<span class="nc" id="L1436">                                    startsWithValue = items[0];</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">                                } else if (items.length == 2) {</span>
<span class="fc" id="L1438">                                    startsWithValue = items[0];</span>
<span class="fc" id="L1439">                                    endsWithValue = items[1];</span>
                                } else {
<span class="fc" id="L1441">                                    startsWithValue = items[0];</span>
<span class="fc" id="L1442">                                    endsWithValue = items[items.length - 1];</span>
<span class="fc" id="L1443">                                    containsValues = new String[items.length - 2];</span>
<span class="fc" id="L1444">                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);</span>
                                }
                            }

<span class="fc" id="L1448">                            filter = new MatchSegement(propertyName, function, startsWithValue, endsWithValue,</span>
                                    containsValues, not);
                        }
<span class="fc" id="L1451">                    } else {</span>
<span class="fc" id="L1452">                        filter = new StringOpSegement(propertyName, function, strValue, op);</span>
                    }

<span class="fc bfc" id="L1455" title="All 2 branches covered.">                    while (ch == ' ') {</span>
<span class="fc" id="L1456">                        next();</span>
                    }

<span class="fc bfc" id="L1459" title="All 4 branches covered.">                    if (ch == '&amp;' || ch == '|') {</span>
<span class="fc" id="L1460">                        filter = filterRest(filter);</span>
                    }

<span class="fc bfc" id="L1463" title="All 2 branches covered.">                    if (predicateFlag) {</span>
<span class="fc" id="L1464">                        accept(')');</span>
                    }
                    
<span class="fc bfc" id="L1467" title="All 2 branches covered.">                    if (acceptBracket) {</span>
<span class="fc" id="L1468">                        accept(']');</span>
                    }

<span class="fc" id="L1471">                    return filter;</span>
                }

<span class="fc bfc" id="L1474" title="All 2 branches covered.">                if (isDigitFirst(ch)) {</span>
<span class="fc" id="L1475">                    long value = readLongValue();</span>
<span class="fc" id="L1476">                    double doubleValue = 0D;</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">                    if (ch == '.') {</span>
<span class="fc" id="L1478">                        doubleValue = readDoubleValue(value);</span>
                        
                    }

                    Filter filter;

<span class="fc bfc" id="L1484" title="All 2 branches covered.">                    if (doubleValue == 0) {</span>
<span class="fc" id="L1485">                        filter = new IntOpSegement(propertyName, function, value, op);</span>
                    } else {
<span class="fc" id="L1487">                        filter = new DoubleOpSegement(propertyName, function, doubleValue, op);</span>
                    }

<span class="fc bfc" id="L1490" title="All 2 branches covered.">                    while (ch == ' ') {</span>
<span class="fc" id="L1491">                        next();</span>
                    }

<span class="pc bpc" id="L1494" title="1 of 4 branches missed.">                    if (lparanCount &gt; 1 &amp;&amp; ch == ')') {</span>
<span class="fc" id="L1495">                        next();</span>
<span class="fc" id="L1496">                        lparanCount--;</span>
                    }

<span class="fc bfc" id="L1499" title="All 4 branches covered.">                    if (ch == '&amp;' || ch == '|') {</span>
<span class="fc" id="L1500">                        filter = filterRest(filter);</span>
                    }

<span class="fc bfc" id="L1503" title="All 2 branches covered.">                    if (predicateFlag) {</span>
<span class="fc" id="L1504">                        lparanCount--;</span>
<span class="fc" id="L1505">                        accept(')');</span>
                    }

<span class="fc bfc" id="L1508" title="All 2 branches covered.">                    if (acceptBracket) {</span>
<span class="fc" id="L1509">                        accept(']');</span>
                    }

<span class="fc" id="L1512">                    return filter;</span>
<span class="fc bfc" id="L1513" title="All 2 branches covered.">                } else if (ch == '$') {</span>
<span class="fc" id="L1514">                    Segment segment = readSegement();</span>
<span class="fc" id="L1515">                    RefOpSegement filter = new RefOpSegement(propertyName, function, segment, op);</span>
<span class="fc" id="L1516">                    hasRefSegment = true;</span>
<span class="pc bpc" id="L1517" title="1 of 2 branches missed.">                    while (ch == ' ') {</span>
<span class="nc" id="L1518">                        next();</span>
                    }

<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">                    if (predicateFlag) {</span>
<span class="fc" id="L1522">                        accept(')');</span>
                    }

<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">                    if (acceptBracket) {</span>
<span class="fc" id="L1526">                        accept(']');</span>
                    }

<span class="fc" id="L1529">                    return filter;</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">                } else if (ch == '/') {</span>
<span class="fc" id="L1531">                    int flags = 0;</span>
<span class="fc" id="L1532">                    StringBuilder regBuf = new StringBuilder();</span>
                    for (;;) {
<span class="fc" id="L1534">                        next();</span>
<span class="fc bfc" id="L1535" title="All 2 branches covered.">                        if (ch == '/') {</span>
<span class="fc" id="L1536">                            next();</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">                            if (ch == 'i') {</span>
<span class="fc" id="L1538">                                next();</span>
<span class="fc" id="L1539">                                flags |= Pattern.CASE_INSENSITIVE;</span>
                            }
                            break;
                        }

<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">                        if (ch == '\\') {</span>
<span class="nc" id="L1545">                            next();</span>
<span class="nc" id="L1546">                            regBuf.append(ch);</span>
                        } else {
<span class="fc" id="L1548">                            regBuf.append(ch);</span>
                        }
                    }

<span class="fc" id="L1552">                    Pattern pattern = Pattern.compile(regBuf.toString(), flags);</span>
<span class="fc" id="L1553">                    RegMatchSegement filter = new RegMatchSegement(propertyName, function, pattern, op);</span>

<span class="pc bpc" id="L1555" title="1 of 2 branches missed.">                    if (predicateFlag) {</span>
<span class="fc" id="L1556">                        accept(')');</span>
                    }

<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">                    if (acceptBracket) {</span>
<span class="fc" id="L1560">                        accept(']');</span>
                    }

<span class="fc" id="L1563">                    return filter;</span>
                }

<span class="fc bfc" id="L1566" title="All 2 branches covered.">                if (ch == 'n') {</span>
<span class="fc" id="L1567">                    String name = readName();</span>
<span class="pc bpc" id="L1568" title="1 of 2 branches missed.">                    if (&quot;null&quot;.equals(name)) {</span>
<span class="fc" id="L1569">                        Filter filter = null;</span>
<span class="fc bfc" id="L1570" title="All 2 branches covered.">                        if (op == Operator.EQ) {</span>
<span class="fc" id="L1571">                            filter = new NullSegement(propertyName, function);</span>
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">                        } else if (op == Operator.NE) {</span>
<span class="fc" id="L1573">                            filter = new NotNullSegement(propertyName, function);</span>
                        }

<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">                        if (filter != null) {</span>
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">                            while (ch == ' ') {</span>
<span class="nc" id="L1578">                                next();</span>
                            }

<span class="pc bpc" id="L1581" title="2 of 4 branches missed.">                            if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1582">                                filter = filterRest(filter);</span>
                            }
                        }

<span class="fc bfc" id="L1586" title="All 2 branches covered.">                        if (predicateFlag) {</span>
<span class="fc" id="L1587">                            accept(')');</span>
                        }
<span class="fc" id="L1589">                        accept(']');</span>

<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">                        if (filter != null) {</span>
<span class="fc" id="L1592">                            return filter;</span>
                        }

<span class="nc" id="L1595">                        throw new UnsupportedOperationException();</span>
                    }
<span class="pc bfc" id="L1597" title="All 2 branches covered.">                } else if (ch == 't') {</span>
<span class="fc" id="L1598">                    String name = readName();</span>
                    
<span class="pc bpc" id="L1600" title="1 of 2 branches missed.">                    if (&quot;true&quot;.equals(name)) {</span>
<span class="fc" id="L1601">                        Filter filter = null;</span>

<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">                        if (op == Operator.EQ) {</span>
<span class="fc" id="L1604">                            filter = new ValueSegment(propertyName, function, Boolean.TRUE, true);</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                        } else if (op == Operator.NE) {</span>
<span class="nc" id="L1606">                            filter = new ValueSegment(propertyName, function, Boolean.TRUE, false);</span>
                        }

<span class="pc bpc" id="L1609" title="1 of 2 branches missed.">                        if (filter != null) {</span>
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">                            while (ch == ' ') {</span>
<span class="nc" id="L1611">                                next();</span>
                            }

<span class="pc bpc" id="L1614" title="2 of 4 branches missed.">                            if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1615">                                filter = filterRest(filter);</span>
                            }
                        }

<span class="pc bpc" id="L1619" title="1 of 2 branches missed.">                        if (predicateFlag) {</span>
<span class="nc" id="L1620">                            accept(')');</span>
                        }
<span class="fc" id="L1622">                        accept(']');</span>

<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">                        if (filter != null) {</span>
<span class="fc" id="L1625">                            return filter;</span>
                        }

<span class="nc" id="L1628">                        throw new UnsupportedOperationException();</span>
                    }
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">                } else if (ch == 'f') {</span>
<span class="fc" id="L1631">                    String name = readName();</span>
                    
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">                    if (&quot;false&quot;.equals(name)) {</span>
<span class="fc" id="L1634">                        Filter filter = null;</span>

<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">                        if (op == Operator.EQ) {</span>
<span class="fc" id="L1637">                            filter = new ValueSegment(propertyName, function, Boolean.FALSE, true);</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">                        } else if (op == Operator.NE) {</span>
<span class="nc" id="L1639">                            filter = new ValueSegment(propertyName, function, Boolean.FALSE, false);</span>
                        }

<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">                        if (filter != null) {</span>
<span class="pc bpc" id="L1643" title="1 of 2 branches missed.">                            while (ch == ' ') {</span>
<span class="nc" id="L1644">                                next();</span>
                            }

<span class="pc bpc" id="L1647" title="2 of 4 branches missed.">                            if (ch == '&amp;' || ch == '|') {</span>
<span class="nc" id="L1648">                                filter = filterRest(filter);</span>
                            }
                        }

<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">                        if (predicateFlag) {</span>
<span class="nc" id="L1653">                            accept(')');</span>
                        }
<span class="fc" id="L1655">                        accept(']');</span>

<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">                        if (filter != null) {</span>
<span class="fc" id="L1658">                            return filter;</span>
                        }

<span class="nc" id="L1661">                        throw new UnsupportedOperationException();</span>
                    }
                }

<span class="nc" id="L1665">                throw new UnsupportedOperationException();</span>
                // accept(')');
            }

<span class="fc" id="L1669">            int start = pos - 1;</span>
<span class="fc" id="L1670">            char startCh = ch;</span>
<span class="fc bfc" id="L1671" title="All 6 branches covered.">            while (ch != ']' &amp;&amp; ch != '/' &amp;&amp; !isEOF()) {</span>
<span class="pc bpc" id="L1672" title="2 of 8 branches missed.">                if (ch == '.' //</span>
                        &amp;&amp; (!predicateFlag) // 
                        &amp;&amp; !predicateFlag
                        &amp;&amp; startCh != '\''
                ) {
<span class="fc" id="L1677">                    break;</span>
                }
                
<span class="fc bfc" id="L1680" title="All 2 branches covered.">                if (ch == '\\') {</span>
<span class="fc" id="L1681">                    next();</span>
                }
<span class="fc" id="L1683">                next();</span>
            }
            
            int end;
<span class="fc bfc" id="L1687" title="All 2 branches covered.">            if (acceptBracket) {</span>
<span class="fc" id="L1688">                end = pos - 1;</span>
            } else {
<span class="fc bfc" id="L1690" title="All 4 branches covered.">                if (ch == '/' || ch == '.') {</span>
<span class="fc" id="L1691">                    end = pos - 1;</span>
                } else {
<span class="fc" id="L1693">                    end = pos;</span>
                }
            }
            
<span class="fc" id="L1697">            String text = path.substring(start, end);</span>

<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">            if (text.indexOf('\\') != 0) {</span>
<span class="fc" id="L1700">                StringBuilder buf = new StringBuilder(text.length());</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">                for (int i = 0; i &lt; text.length(); ++i) {</span>
<span class="fc" id="L1702">                    char ch = text.charAt(i);</span>
<span class="pc bpc" id="L1703" title="1 of 4 branches missed.">                    if (ch == '\\' &amp;&amp; i &lt; text.length() - 1) {</span>
<span class="fc" id="L1704">                        char c2 = text.charAt(i + 1);</span>
<span class="pc bpc" id="L1705" title="3 of 6 branches missed.">                        if (c2 == '@' || ch == '\\' || ch == '\&quot;') {</span>
<span class="fc" id="L1706">                            buf.append(c2);</span>
<span class="fc" id="L1707">                            i++;</span>
<span class="fc" id="L1708">                            continue;</span>
                        }
                    }

<span class="fc" id="L1712">                    buf.append(ch);</span>
                }
<span class="fc" id="L1714">                text = buf.toString();</span>
            }
            
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">            if (text.indexOf(&quot;\\.&quot;) != -1) {</span>
                String propName;
<span class="nc bnc" id="L1719" title="All 6 branches missed.">                if (startCh == '\'' &amp;&amp; text.length() &gt; 2 &amp;&amp; text.charAt(text.length() - 1) == startCh) {</span>
<span class="nc" id="L1720">                    propName = text.substring(1, text.length() - 1);</span>
                } else {
<span class="nc" id="L1722">                    propName = text.replaceAll(&quot;\\\\\\.&quot;, &quot;\\.&quot;);</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                    if (propName.indexOf(&quot;\\-&quot;) != -1) {</span>
<span class="nc" id="L1724">                        propName = propName.replaceAll(&quot;\\\\-&quot;, &quot;-&quot;);</span>
                    }
                }

<span class="nc bnc" id="L1728" title="All 2 branches missed.">                if (predicateFlag) {</span>
<span class="nc" id="L1729">                    accept(')');</span>
                }

<span class="nc" id="L1732">                return new PropertySegment(propName, false);</span>
            }

<span class="fc" id="L1735">            Segment segment = buildArraySegement(text);</span>

<span class="fc bfc" id="L1737" title="All 4 branches covered.">            if (acceptBracket &amp;&amp; !isEOF()) {</span>
<span class="fc" id="L1738">                accept(']');</span>
            }

<span class="fc" id="L1741">            return segment;</span>
        }

        Filter filterRest(Filter filter) {
<span class="fc bfc" id="L1745" title="All 2 branches covered.">            boolean and = ch == '&amp;';</span>
<span class="pc bpc" id="L1746" title="3 of 8 branches missed.">            if ((ch == '&amp;' &amp;&amp; getNextChar() == '&amp;') || (ch == '|' &amp;&amp; getNextChar() == '|')) {</span>
<span class="fc" id="L1747">                next();</span>
<span class="fc" id="L1748">                next();</span>

<span class="fc" id="L1750">                boolean paren = false;</span>
<span class="fc bfc" id="L1751" title="All 2 branches covered.">                if (ch == '(') {</span>
<span class="fc" id="L1752">                    paren = true;</span>
<span class="fc" id="L1753">                    next();</span>
                }

<span class="fc bfc" id="L1756" title="All 2 branches covered.">                while (ch == ' ') {</span>
<span class="fc" id="L1757">                    next();</span>
                }

<span class="fc" id="L1760">                Filter right = (Filter) parseArrayAccessFilter(false);</span>

<span class="fc" id="L1762">                filter = new FilterGroup(filter, right, and);</span>

<span class="pc bpc" id="L1764" title="1 of 4 branches missed.">                if (paren &amp;&amp; ch == ')') {</span>
<span class="fc" id="L1765">                    next();</span>
                }
            }
<span class="fc" id="L1768">            return filter;</span>
        }

        protected long readLongValue() {
<span class="fc" id="L1772">            int beginIndex = pos - 1;</span>
<span class="pc bpc" id="L1773" title="2 of 4 branches missed.">            if (ch == '+' || ch == '-') {</span>
<span class="nc" id="L1774">                next();</span>
            }

<span class="fc bfc" id="L1777" title="All 4 branches covered.">            while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {</span>
<span class="fc" id="L1778">                next();</span>
            }

<span class="fc" id="L1781">            int endIndex = pos - 1;</span>
<span class="fc" id="L1782">            String text = path.substring(beginIndex, endIndex);</span>
<span class="fc" id="L1783">            long value = Long.parseLong(text);</span>
<span class="fc" id="L1784">            return value;</span>
        }
        
        protected double readDoubleValue(long longValue) {
<span class="fc" id="L1788">            int beginIndex = pos - 1;</span>

<span class="fc" id="L1790">            next();</span>
<span class="pc bpc" id="L1791" title="1 of 4 branches missed.">            while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {</span>
<span class="fc" id="L1792">                next();</span>
            }

<span class="fc" id="L1795">            int endIndex = pos - 1;</span>
<span class="fc" id="L1796">            String text = path.substring(beginIndex, endIndex);</span>
<span class="fc" id="L1797">            double value = Double.parseDouble(text);</span>
<span class="fc" id="L1798">            value += longValue;</span>
<span class="fc" id="L1799">            return value;</span>
        }

        protected Object readValue() {
<span class="fc" id="L1803">            skipWhitespace();</span>

<span class="fc bfc" id="L1805" title="All 2 branches covered.">            if (isDigitFirst(ch)) {</span>
<span class="fc" id="L1806">                return readLongValue();</span>
            }

<span class="pc bpc" id="L1809" title="1 of 4 branches missed.">            if (ch == '&quot;' || ch == '\'') {</span>
<span class="fc" id="L1810">                return readString();</span>
            }

<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">            if (ch == 'n') {</span>
<span class="fc" id="L1814">                String name = readName();</span>

<span class="pc bpc" id="L1816" title="1 of 2 branches missed.">                if (&quot;null&quot;.equals(name)) {</span>
<span class="fc" id="L1817">                    return null;</span>
                } else {
<span class="nc" id="L1819">                    throw new JSONPathException(path);</span>
                }
            }

<span class="nc" id="L1823">            throw new UnsupportedOperationException();</span>
        }

        static boolean isDigitFirst(char ch) {
<span class="pc bpc" id="L1827" title="2 of 8 branches missed.">            return ch == '-' || ch == '+' || (ch &gt;= '0' &amp;&amp; ch &lt;= '9');</span>
        }

        protected Operator readOp() {
<span class="fc" id="L1831">            Operator op = null;</span>
<span class="fc bfc" id="L1832" title="All 2 branches covered.">            if (ch == '=') {</span>
<span class="fc" id="L1833">                next();</span>
<span class="fc bfc" id="L1834" title="All 2 branches covered.">                if (ch == '~') {</span>
<span class="fc" id="L1835">                    next();</span>
<span class="fc" id="L1836">                    op = Operator.REG_MATCH;</span>
<span class="fc bfc" id="L1837" title="All 2 branches covered.">                } else if (ch == '=') {</span>
<span class="fc" id="L1838">                    next();</span>
<span class="fc" id="L1839">                    op = Operator.EQ;</span>
                } else {
<span class="fc" id="L1841">                    op = Operator.EQ;</span>
                }
<span class="fc bfc" id="L1843" title="All 2 branches covered.">            } else if (ch == '!') {</span>
<span class="fc" id="L1844">                next();</span>
<span class="fc" id="L1845">                accept('=');</span>
<span class="fc" id="L1846">                op = Operator.NE;</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">            } else if (ch == '&lt;') {</span>
<span class="fc" id="L1848">                next();</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">                if (ch == '=') {</span>
<span class="fc" id="L1850">                    next();</span>
<span class="fc" id="L1851">                    op = Operator.LE;</span>
                } else {
<span class="fc" id="L1853">                    op = Operator.LT;</span>
                }
<span class="fc bfc" id="L1855" title="All 2 branches covered.">            } else if (ch == '&gt;') {</span>
<span class="fc" id="L1856">                next();</span>
<span class="fc bfc" id="L1857" title="All 2 branches covered.">                if (ch == '=') {</span>
<span class="fc" id="L1858">                    next();</span>
<span class="fc" id="L1859">                    op = Operator.GE;</span>
                } else {
<span class="fc" id="L1861">                    op = Operator.GT;</span>
                }
            }

<span class="fc bfc" id="L1865" title="All 2 branches covered.">            if (op == null) {</span>
<span class="fc" id="L1866">                String name = readName();</span>

<span class="fc bfc" id="L1868" title="All 2 branches covered.">                if (&quot;not&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1869">                    skipWhitespace();</span>

<span class="fc" id="L1871">                    name = readName();</span>

<span class="fc bfc" id="L1873" title="All 2 branches covered.">                    if (&quot;like&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1874">                        op = Operator.NOT_LIKE;</span>
<span class="fc bfc" id="L1875" title="All 2 branches covered.">                    } else if (&quot;rlike&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1876">                        op = Operator.NOT_RLIKE;</span>
<span class="fc bfc" id="L1877" title="All 2 branches covered.">                    } else if (&quot;in&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1878">                        op = Operator.NOT_IN;</span>
<span class="pc bpc" id="L1879" title="1 of 2 branches missed.">                    } else if (&quot;between&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1880">                        op = Operator.NOT_BETWEEN;</span>
                    } else {
<span class="nc" id="L1882">                        throw new UnsupportedOperationException();</span>
                    }
<span class="fc bfc" id="L1884" title="All 2 branches covered.">                } else if (&quot;nin&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1885">                    op = Operator.NOT_IN;</span>
                } else {
<span class="fc bfc" id="L1887" title="All 2 branches covered.">                    if (&quot;like&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1888">                        op = Operator.LIKE;</span>
<span class="fc bfc" id="L1889" title="All 2 branches covered.">                    } else if (&quot;rlike&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1890">                        op = Operator.RLIKE;</span>
<span class="fc bfc" id="L1891" title="All 2 branches covered.">                    } else if (&quot;in&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1892">                        op = Operator.IN;</span>
<span class="pc bpc" id="L1893" title="1 of 2 branches missed.">                    } else if (&quot;between&quot;.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L1894">                        op = Operator.BETWEEN;</span>
                    } else {
<span class="nc" id="L1896">                        throw new UnsupportedOperationException();</span>
                    }
                }
            }
<span class="fc" id="L1900">            return op;</span>
        }

        String readName() {
<span class="fc" id="L1904">            skipWhitespace();</span>

<span class="fc bfc" id="L1906" title="All 4 branches covered.">            if (ch != '\\' &amp;&amp; !Character.isJavaIdentifierStart(ch)) {</span>
<span class="fc" id="L1907">                throw new JSONPathException(&quot;illeal jsonpath syntax. &quot; + path);</span>
            }

<span class="fc" id="L1910">            StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L1911" title="All 2 branches covered.">            while (!isEOF()) {</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">                if (ch == '\\') {</span>
<span class="fc" id="L1913">                    next();</span>
<span class="fc" id="L1914">                    buf.append(ch);</span>
<span class="fc bfc" id="L1915" title="All 2 branches covered.">                    if (isEOF()) {</span>
<span class="fc" id="L1916">                        return buf.toString();</span>
                    }
<span class="fc" id="L1918">                    next();</span>
<span class="fc" id="L1919">                    continue;</span>
                }

<span class="fc" id="L1922">                boolean identifierFlag = Character.isJavaIdentifierPart(ch);</span>
<span class="fc bfc" id="L1923" title="All 2 branches covered.">                if (!identifierFlag) {</span>
<span class="fc" id="L1924">                    break;</span>
                }
<span class="fc" id="L1926">                buf.append(ch);</span>
<span class="fc" id="L1927">                next();</span>
<span class="fc" id="L1928">            }</span>

<span class="fc bfc" id="L1930" title="All 4 branches covered.">            if (isEOF() &amp;&amp; Character.isJavaIdentifierPart(ch)) {</span>
<span class="fc" id="L1931">                buf.append(ch);</span>
            }

<span class="fc" id="L1934">            return buf.toString();</span>
        }

        String readString() {
<span class="fc" id="L1938">            char quoate = ch;</span>
<span class="fc" id="L1939">            next();</span>

<span class="fc" id="L1941">            int beginIndex = pos - 1;</span>
<span class="pc bpc" id="L1942" title="1 of 4 branches missed.">            while (ch != quoate &amp;&amp; !isEOF()) {</span>
<span class="fc" id="L1943">                next();</span>
            }

<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">            String strValue = path.substring(beginIndex, isEOF() ? pos : pos - 1);</span>

<span class="fc" id="L1948">            accept(quoate);</span>

<span class="fc" id="L1950">            return strValue;</span>
        }

        void accept(char expect) {
<span class="fc bfc" id="L1954" title="All 2 branches covered.">            if (ch == ' ') {</span>
<span class="fc" id="L1955">                next();</span>
            }

<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">            if (ch != expect) {</span>
<span class="nc" id="L1959">                throw new JSONPathException(&quot;expect '&quot; + expect + &quot;, but '&quot; + ch + &quot;'&quot;);</span>
            }

<span class="fc bfc" id="L1962" title="All 2 branches covered.">            if (!isEOF()) {</span>
<span class="fc" id="L1963">                next();</span>
            }
<span class="fc" id="L1965">        }</span>

        public Segment[] explain() {
<span class="pc bpc" id="L1968" title="2 of 4 branches missed.">            if (path == null || path.length() == 0) {</span>
<span class="nc" id="L1969">                throw new IllegalArgumentException();</span>
            }

<span class="fc" id="L1972">            Segment[] segments = new Segment[8];</span>

            for (;;) {
<span class="fc" id="L1975">                Segment segment = readSegement();</span>
<span class="fc bfc" id="L1976" title="All 2 branches covered.">                if (segment == null) {</span>
<span class="fc" id="L1977">                    break;</span>
                }

<span class="fc bfc" id="L1980" title="All 2 branches covered.">                if (segment instanceof PropertySegment) {</span>
<span class="fc" id="L1981">                    PropertySegment propertySegment = (PropertySegment) segment;</span>
<span class="fc bfc" id="L1982" title="All 4 branches covered.">                    if ((!propertySegment.deep) &amp;&amp; propertySegment.propertyName.equals(&quot;*&quot;)) {</span>
<span class="fc" id="L1983">                        continue;</span>
                    }
                }

<span class="fc bfc" id="L1987" title="All 2 branches covered.">                if (level == segments.length) {</span>
<span class="fc" id="L1988">                    Segment[] t = new Segment[level * 3 / 2];</span>
<span class="fc" id="L1989">                    System.arraycopy(segments, 0, t, 0, level);</span>
<span class="fc" id="L1990">                    segments = t;</span>
                }
<span class="fc" id="L1992">                segments[level++] = segment;</span>
<span class="fc" id="L1993">            }</span>

<span class="fc bfc" id="L1995" title="All 2 branches covered.">            if (level == segments.length) {</span>
<span class="fc" id="L1996">                return segments;</span>
            }

<span class="fc" id="L1999">            Segment[] result = new Segment[level];</span>
<span class="fc" id="L2000">            System.arraycopy(segments, 0, result, 0, level);</span>
<span class="fc" id="L2001">            return result;</span>
        }

        Segment buildArraySegement(String indexText) {
<span class="fc" id="L2005">            final int indexTextLen = indexText.length();</span>
<span class="fc" id="L2006">            final char firstChar = indexText.charAt(0);</span>
<span class="fc" id="L2007">            final char lastChar = indexText.charAt(indexTextLen - 1);</span>

<span class="fc" id="L2009">            int commaIndex = indexText.indexOf(',');</span>

<span class="pc bpc" id="L2011" title="1 of 6 branches missed.">            if (indexText.length() &gt; 2 &amp;&amp; firstChar == '\'' &amp;&amp; lastChar == '\'') {</span>

<span class="fc" id="L2013">                String propertyName = indexText.substring(1, indexTextLen - 1);</span>

<span class="fc bfc" id="L2015" title="All 4 branches covered.">                if (commaIndex == -1 || !strArrayPatternx.matcher(indexText).find()) {</span>
<span class="fc" id="L2016">                    return new PropertySegment(propertyName, false);</span>
                }

<span class="fc" id="L2019">                String[] propertyNames = propertyName.split(strArrayRegex);</span>
<span class="fc" id="L2020">                return new MultiPropertySegment(propertyNames);</span>
            }

<span class="fc" id="L2023">            int colonIndex = indexText.indexOf(':');</span>

<span class="fc bfc" id="L2025" title="All 4 branches covered.">            if (commaIndex == -1 &amp;&amp; colonIndex == -1) {</span>
<span class="fc bfc" id="L2026" title="All 2 branches covered.">                if (TypeUtils.isNumber(indexText)) {</span>
                    try {
<span class="fc" id="L2028">                        int index = Integer.parseInt(indexText);</span>
<span class="fc" id="L2029">                        return new ArrayAccessSegment(index);</span>
<span class="fc" id="L2030">                    }catch (NumberFormatException ex){</span>
<span class="fc" id="L2031">                        return new PropertySegment(indexText, false); // fix ISSUE-1208</span>
                    }
                } else {
<span class="pc bpc" id="L2034" title="1 of 4 branches missed.">                    if (indexText.charAt(0) == '&quot;' &amp;&amp; indexText.charAt(indexText.length() - 1) == '&quot;') {</span>
<span class="fc" id="L2035">                        indexText = indexText.substring(1, indexText.length() - 1);</span>
                    }
<span class="fc" id="L2037">                    return new PropertySegment(indexText, false);</span>
                }
            }

<span class="fc bfc" id="L2041" title="All 2 branches covered.">            if (commaIndex != -1) {</span>
<span class="fc" id="L2042">                String[] indexesText = indexText.split(&quot;,&quot;);</span>
<span class="fc" id="L2043">                int[] indexes = new int[indexesText.length];</span>
<span class="fc bfc" id="L2044" title="All 2 branches covered.">                for (int i = 0; i &lt; indexesText.length; ++i) {</span>
<span class="fc" id="L2045">                    indexes[i] = Integer.parseInt(indexesText[i]);</span>
                }
<span class="fc" id="L2047">                return new MultiIndexSegment(indexes);</span>
            }

<span class="pc bpc" id="L2050" title="1 of 2 branches missed.">            if (colonIndex != -1) {</span>
<span class="fc" id="L2051">                String[] indexesText = indexText.split(&quot;:&quot;);</span>
<span class="fc" id="L2052">                int[] indexes = new int[indexesText.length];</span>
<span class="fc bfc" id="L2053" title="All 2 branches covered.">                for (int i = 0; i &lt; indexesText.length; ++i) {</span>
<span class="fc" id="L2054">                    String str = indexesText[i];</span>
<span class="fc bfc" id="L2055" title="All 2 branches covered.">                    if (str.length() == 0) {</span>
<span class="pc bpc" id="L2056" title="1 of 2 branches missed.">                        if (i == 0) {</span>
<span class="fc" id="L2057">                            indexes[i] = 0;</span>
                        } else {
<span class="nc" id="L2059">                            throw new UnsupportedOperationException();</span>
                        }
                    } else {
<span class="fc" id="L2062">                        indexes[i] = Integer.parseInt(str);</span>
                    }
                }

<span class="fc" id="L2066">                int start = indexes[0];</span>
                int end;
<span class="fc bfc" id="L2068" title="All 2 branches covered.">                if (indexes.length &gt; 1) {</span>
<span class="fc" id="L2069">                    end = indexes[1];</span>
                } else {
<span class="fc" id="L2071">                    end = -1;</span>
                }
                int step;
<span class="fc bfc" id="L2074" title="All 2 branches covered.">                if (indexes.length == 3) {</span>
<span class="fc" id="L2075">                    step = indexes[2];</span>
                } else {
<span class="fc" id="L2077">                    step = 1;</span>
                }

<span class="pc bpc" id="L2080" title="1 of 4 branches missed.">                if (end &gt;= 0 &amp;&amp; end &lt; start) {</span>
<span class="nc" id="L2081">                    throw new UnsupportedOperationException(&quot;end must greater than or equals start. start &quot; + start</span>
                                                            + &quot;,  end &quot; + end);
                }

<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">                if (step &lt;= 0) {</span>
<span class="nc" id="L2086">                    throw new UnsupportedOperationException(&quot;step must greater than zero : &quot; + step);</span>
                }
<span class="fc" id="L2088">                return new RangeSegment(start, end, step);</span>
            }

<span class="nc" id="L2091">            throw new UnsupportedOperationException();</span>
        }
    }

    interface Segment {

        Object eval(JSONPath path, Object rootObject, Object currentObject);
        void extract(JSONPath path, DefaultJSONParser parser, Context context);
    }


<span class="fc" id="L2102">    static class SizeSegment implements Segment {</span>
<span class="fc" id="L2103">        public final static SizeSegment instance = new SizeSegment();</span>
        public Integer eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2105">            return path.evalSize(currentObject);</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="fc" id="L2109">            Object object = parser.parse();</span>
<span class="fc" id="L2110">            context.object = path.evalSize(object);</span>
<span class="fc" id="L2111">        }</span>
    }

<span class="fc" id="L2114">    static class TypeSegment implements Segment {</span>
<span class="fc" id="L2115">        public final static TypeSegment instance = new TypeSegment();</span>

        public String eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc bfc" id="L2118" title="All 2 branches covered.">            if (currentObject == null) {</span>
<span class="fc" id="L2119">                return &quot;null&quot;;</span>
            }

<span class="fc bfc" id="L2122" title="All 2 branches covered.">            if (currentObject instanceof Collection) {</span>
<span class="fc" id="L2123">                return &quot;array&quot;;</span>
            }

<span class="fc bfc" id="L2126" title="All 2 branches covered.">            if (currentObject instanceof Number) {</span>
<span class="fc" id="L2127">                return &quot;number&quot;;</span>
            }

<span class="fc bfc" id="L2130" title="All 2 branches covered.">            if (currentObject instanceof Boolean) {</span>
<span class="fc" id="L2131">                return &quot;boolean&quot;;</span>
            }

<span class="fc bfc" id="L2134" title="All 6 branches covered.">            if (currentObject instanceof String</span>
                    || currentObject instanceof UUID
                    || currentObject instanceof Enum) {
<span class="fc" id="L2137">                return &quot;string&quot;;</span>
            }

<span class="fc" id="L2140">            return &quot;object&quot;;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="nc" id="L2144">            throw new UnsupportedOperationException();</span>
        }
    }

<span class="fc" id="L2148">    static class FloorSegment implements Segment {</span>
<span class="fc" id="L2149">        public final static FloorSegment instance = new FloorSegment();</span>
        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc bfc" id="L2151" title="All 2 branches covered.">            if (currentObject instanceof JSONArray) {</span>
<span class="fc" id="L2152">                JSONArray array = ((JSONArray) ((JSONArray) currentObject).clone());</span>
<span class="fc bfc" id="L2153" title="All 2 branches covered.">                for (int i = 0; i &lt; array.size(); i++) {</span>
<span class="fc" id="L2154">                    Object item = array.get(i);</span>
<span class="fc" id="L2155">                    Object newItem = floor(item);</span>
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">                    if (newItem != item) {</span>
<span class="fc" id="L2157">                        array.set(i , newItem);</span>
                    }
                }
<span class="fc" id="L2160">                return array;</span>
            }

<span class="fc" id="L2163">            return floor(currentObject);</span>
        }

        private static Object floor(Object item) {
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">            if (item == null) {</span>
<span class="nc" id="L2168">                return null;</span>
            }

<span class="fc bfc" id="L2171" title="All 2 branches covered.">            if (item instanceof Float) {</span>
<span class="fc" id="L2172">                return Math.floor((Float) item);</span>
            }

<span class="fc bfc" id="L2175" title="All 2 branches covered.">            if (item instanceof Double) {</span>
<span class="fc" id="L2176">                return Math.floor((Double) item);</span>
            }

<span class="fc bfc" id="L2179" title="All 2 branches covered.">            if (item instanceof BigDecimal) {</span>
<span class="fc" id="L2180">                BigDecimal decimal = (BigDecimal) item;</span>
<span class="fc" id="L2181">                return decimal.setScale(0, RoundingMode.FLOOR);</span>
            }

<span class="pc bpc" id="L2184" title="1 of 10 branches missed.">            if (item instanceof Byte</span>
                    || item instanceof Short
                    || item instanceof Integer
                    || item instanceof Long
                    || item instanceof BigInteger) {
<span class="fc" id="L2189">                return item;</span>
            }

<span class="nc" id="L2192">            throw new UnsupportedOperationException();</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="nc" id="L2196">            throw new UnsupportedOperationException();</span>
        }
    }

<span class="fc" id="L2200">    static class MaxSegment implements Segment {</span>

<span class="fc" id="L2202">        public final static MaxSegment instance = new MaxSegment();</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2205">            Object max = null;</span>
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">            if (currentObject instanceof Collection) {</span>
<span class="fc" id="L2207">                Iterator iterator = ((Collection) currentObject).iterator();</span>
<span class="fc bfc" id="L2208" title="All 2 branches covered.">                while (iterator.hasNext()) {</span>
<span class="fc" id="L2209">                    Object next = iterator.next();</span>
<span class="pc bpc" id="L2210" title="1 of 2 branches missed.">                    if (next == null) {</span>
<span class="nc" id="L2211">                        continue;</span>
                    }

<span class="fc bfc" id="L2214" title="All 2 branches covered.">                    if (max == null) {</span>
<span class="fc" id="L2215">                        max = next;</span>
<span class="fc bfc" id="L2216" title="All 2 branches covered.">                    } else if (compare(max, next) &lt; 0) {</span>
<span class="fc" id="L2217">                        max = next;</span>
                    }
<span class="fc" id="L2219">                }</span>
<span class="fc" id="L2220">            } else {</span>
<span class="nc" id="L2221">                throw new UnsupportedOperationException();</span>
            }

<span class="fc" id="L2224">            return max;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="nc" id="L2228">            throw new UnsupportedOperationException();</span>
        }
    }

<span class="fc" id="L2232">    static class MinSegment implements Segment {</span>
<span class="fc" id="L2233">        public final static MinSegment instance = new MinSegment();</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2236">            Object min = null;</span>
<span class="pc bpc" id="L2237" title="1 of 2 branches missed.">            if (currentObject instanceof Collection) {</span>
<span class="fc" id="L2238">                Iterator iterator = ((Collection) currentObject).iterator();</span>
<span class="fc bfc" id="L2239" title="All 2 branches covered.">                while (iterator.hasNext()) {</span>
<span class="fc" id="L2240">                    Object next = iterator.next();</span>
<span class="pc bpc" id="L2241" title="1 of 2 branches missed.">                    if (next == null) {</span>
<span class="nc" id="L2242">                        continue;</span>
                    }

<span class="fc bfc" id="L2245" title="All 2 branches covered.">                    if (min == null) {</span>
<span class="fc" id="L2246">                        min = next;</span>
<span class="pc bpc" id="L2247" title="1 of 2 branches missed.">                    } else if (compare(min, next) &gt; 0) {</span>
<span class="nc" id="L2248">                        min = next;</span>
                    }
<span class="fc" id="L2250">                }</span>
<span class="fc" id="L2251">            } else {</span>
<span class="nc" id="L2252">                throw new UnsupportedOperationException();</span>
            }

<span class="fc" id="L2255">            return min;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="nc" id="L2259">            throw new UnsupportedOperationException();</span>
        }
    }

    static int compare(Object a, Object b) {
<span class="fc bfc" id="L2264" title="All 2 branches covered.">        if (a.getClass() == b.getClass()) {</span>
<span class="fc" id="L2265">            return ((Comparable) a).compareTo(b);</span>
        }

<span class="fc" id="L2268">        Class typeA = a.getClass();</span>
<span class="fc" id="L2269">        Class typeB = b.getClass();</span>

<span class="fc bfc" id="L2271" title="All 2 branches covered.">        if (typeA == BigDecimal.class) {</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">            if (typeB == Integer.class) {</span>
<span class="fc" id="L2273">                b = new BigDecimal((Integer) b);</span>
<span class="pc bpc" id="L2274" title="1 of 2 branches missed.">            } else if (typeB == Long.class) {</span>
<span class="fc" id="L2275">                b = new BigDecimal((Long) b);</span>
<span class="nc bnc" id="L2276" title="All 2 branches missed.">            } else if (typeB == Float.class) {</span>
<span class="nc" id="L2277">                b = new BigDecimal((Float) b);</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">            } else if (typeB == Double.class) {</span>
<span class="nc" id="L2279">                b = new BigDecimal((Double) b);</span>
            }
<span class="fc bfc" id="L2281" title="All 2 branches covered.">        } else if (typeA == Long.class) {</span>
<span class="fc bfc" id="L2282" title="All 2 branches covered.">            if (typeB == Integer.class) {</span>
<span class="fc" id="L2283">                b = new Long((Integer) b);</span>
<span class="pc bpc" id="L2284" title="1 of 2 branches missed.">            } else if (typeB == BigDecimal.class) {</span>
<span class="nc" id="L2285">                a = new BigDecimal((Long) a);</span>
<span class="fc bfc" id="L2286" title="All 2 branches covered.">            } else if (typeB == Float.class) {</span>
<span class="fc" id="L2287">                a = new Float((Long) a);</span>
<span class="pc bpc" id="L2288" title="1 of 2 branches missed.">            } else if (typeB == Double.class) {</span>
<span class="fc" id="L2289">                a = new Double((Long) a);</span>
            }
<span class="fc bfc" id="L2291" title="All 2 branches covered.">        } else if (typeA == Integer.class) {</span>
<span class="fc bfc" id="L2292" title="All 2 branches covered.">            if (typeB == Long.class) {</span>
<span class="fc" id="L2293">                a = new Long((Integer) a);</span>
<span class="fc bfc" id="L2294" title="All 2 branches covered.">            } else if (typeB == BigDecimal.class) {</span>
<span class="fc" id="L2295">                a = new BigDecimal((Integer) a);</span>
<span class="fc bfc" id="L2296" title="All 2 branches covered.">            } else if (typeB == Float.class) {</span>
<span class="fc" id="L2297">                a = new Float((Integer) a);</span>
<span class="pc bpc" id="L2298" title="1 of 2 branches missed.">            } else if (typeB == Double.class) {</span>
<span class="fc" id="L2299">                a = new Double((Integer) a);</span>
            }
<span class="fc bfc" id="L2301" title="All 2 branches covered.">        } else if (typeA == Double.class) {</span>
<span class="fc bfc" id="L2302" title="All 2 branches covered.">            if (typeB == Integer.class) {</span>
<span class="fc" id="L2303">                b = new Double((Integer) b);</span>
<span class="pc bpc" id="L2304" title="1 of 2 branches missed.">            } else if (typeB == Long.class) {</span>
<span class="fc" id="L2305">                b = new Double((Long) b);</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">            } else if (typeB == Float.class) {</span>
<span class="nc" id="L2307">                b = new Double((Float) b);</span>
            }
<span class="pc bpc" id="L2309" title="1 of 2 branches missed.">        } else if (typeA == Float.class) {</span>
<span class="fc bfc" id="L2310" title="All 2 branches covered.">            if (typeB == Integer.class) {</span>
<span class="fc" id="L2311">                b = new Float((Integer) b);</span>
<span class="pc bpc" id="L2312" title="1 of 2 branches missed.">            } else if (typeB == Long.class) {</span>
<span class="fc" id="L2313">                b = new Float((Long) b);</span>
<span class="nc bnc" id="L2314" title="All 2 branches missed.">            } else if (typeB == Double.class) {</span>
<span class="nc" id="L2315">                a = new Double((Float) a);</span>
            }
        }

<span class="fc" id="L2319">        return ((Comparable) a).compareTo(b);</span>
    }

<span class="fc" id="L2322">    static class KeySetSegment implements Segment {</span>

<span class="fc" id="L2324">        public final static KeySetSegment instance = new KeySetSegment();</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2327">            return path.evalKeySet(currentObject);</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="nc" id="L2331">            throw new UnsupportedOperationException();</span>
        }
    }

    static class PropertySegment implements Segment {

        private final String  propertyName;
        private final long    propertyNameHash;
        private final boolean deep;

<span class="fc" id="L2341">        public PropertySegment(String propertyName, boolean deep){</span>
<span class="fc" id="L2342">            this.propertyName = propertyName;</span>
<span class="fc" id="L2343">            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);</span>
<span class="fc" id="L2344">            this.deep = deep;</span>
<span class="fc" id="L2345">        }</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc bfc" id="L2348" title="All 2 branches covered.">            if (deep) {</span>
<span class="fc" id="L2349">                List&lt;Object&gt; results = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L2350">                path.deepScan(currentObject, propertyName, results);</span>
<span class="fc" id="L2351">                return results;</span>
            } else {
                // return path.getPropertyValue(currentObject, propertyName, true);
<span class="fc" id="L2354">                return path.getPropertyValue(currentObject, propertyName, propertyNameHash);</span>
            }
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="fc" id="L2359">            JSONLexerBase lexer = (JSONLexerBase) parser.lexer;</span>

<span class="fc bfc" id="L2361" title="All 4 branches covered.">            if (deep &amp;&amp; context.object == null) {</span>
<span class="fc" id="L2362">                context.object = new JSONArray();</span>
            }

<span class="fc bfc" id="L2365" title="All 2 branches covered.">            if (lexer.token() == JSONToken.LBRACKET) {</span>
<span class="pc bpc" id="L2366" title="1 of 2 branches missed.">                if (&quot;*&quot;.equals(propertyName)) {</span>
<span class="nc" id="L2367">                    return;</span>
                }

<span class="fc" id="L2370">                lexer.nextToken();</span>
                JSONArray array;

<span class="fc bfc" id="L2373" title="All 2 branches covered.">                if (deep) {</span>
<span class="fc" id="L2374">                    array =(JSONArray) context.object;</span>
                } else {
<span class="fc" id="L2376">                    array = new JSONArray();</span>
                }
                for (;;) {
<span class="fc bfc" id="L2379" title="All 4 branches covered.">                    switch (lexer.token()) {</span>
                        case JSONToken.LBRACE: {
<span class="fc bfc" id="L2381" title="All 2 branches covered.">                            if (deep) {</span>
<span class="fc" id="L2382">                                extract(path, parser, context);</span>
<span class="fc" id="L2383">                                break;</span>
                            }
<span class="fc" id="L2385">                            int matchStat = lexer.seekObjectToField(propertyNameHash, deep);</span>
<span class="fc bfc" id="L2386" title="All 2 branches covered.">                            if (matchStat == JSONLexer.VALUE) {</span>
                                Object value;
<span class="pc bpc" id="L2388" title="1 of 3 branches missed.">                                switch (lexer.token()) {</span>
                                    case JSONToken.LITERAL_INT:
<span class="nc" id="L2390">                                        value = lexer.integerValue();</span>
<span class="nc" id="L2391">                                        lexer.nextToken();</span>
<span class="nc" id="L2392">                                        break;</span>
                                    case JSONToken.LITERAL_STRING:
<span class="fc" id="L2394">                                        value = lexer.stringVal();</span>
<span class="fc" id="L2395">                                        lexer.nextToken();</span>
<span class="fc" id="L2396">                                        break;</span>
                                    default:
<span class="fc" id="L2398">                                        value = parser.parse();</span>
                                        break;
                                }

<span class="fc" id="L2402">                                array.add(value);</span>
<span class="pc bpc" id="L2403" title="1 of 2 branches missed.">                                if (lexer.token() == JSONToken.RBRACE) {</span>
<span class="nc" id="L2404">                                    lexer.nextToken();</span>
<span class="nc" id="L2405">                                    continue;</span>
                                } else {
<span class="fc" id="L2407">                                    lexer.skipObject(false);</span>
                                }
<span class="pc bpc" id="L2409" title="1 of 2 branches missed.">                            } else if (matchStat == JSONLexer.NOT_MATCH) {</span>
<span class="fc" id="L2410">                                continue;</span>
                            } else {
<span class="nc bnc" id="L2412" title="All 2 branches missed.">                                if (deep) {</span>
<span class="nc" id="L2413">                                    throw new UnsupportedOperationException(lexer.info());</span>
                                } else {
<span class="nc" id="L2415">                                    lexer.skipObject(false);</span>
                                }
                            }
<span class="nc" id="L2418">                            break;</span>
                        }
                        case JSONToken.LBRACKET:
<span class="pc bpc" id="L2421" title="1 of 2 branches missed.">                            if (deep) {</span>
<span class="fc" id="L2422">                                extract(path, parser, context);</span>
                            } else {
<span class="nc" id="L2424">                                lexer.skipObject(false);</span>
                            }
<span class="nc" id="L2426">                            break;</span>
                        case JSONToken.LITERAL_STRING:
                        case JSONToken.LITERAL_INT:
                        case JSONToken.LITERAL_FLOAT:
                        case JSONToken.LITERAL_ISO8601_DATE:
                        case JSONToken.TRUE:
                        case JSONToken.FALSE:
                        case JSONToken.NULL:
<span class="fc" id="L2434">                            lexer.nextToken();</span>
<span class="fc" id="L2435">                            break;</span>
                        default:
                            break;
                    }

<span class="fc bfc" id="L2440" title="All 2 branches covered.">                    if (lexer.token() == JSONToken.RBRACKET) {</span>
<span class="fc" id="L2441">                        lexer.nextToken();</span>
<span class="fc" id="L2442">                        break;</span>
<span class="pc bpc" id="L2443" title="1 of 2 branches missed.">                    } else if (lexer.token() == JSONToken.COMMA) {</span>
<span class="fc" id="L2444">                        lexer.nextToken();</span>
<span class="fc" id="L2445">                        continue;</span>
                    } else {
<span class="nc" id="L2447">                        throw new JSONException(&quot;illegal json : &quot; + lexer.info());</span>
                    }
                }

<span class="fc bfc" id="L2451" title="All 2 branches covered.">                if (!deep) {</span>
<span class="fc bfc" id="L2452" title="All 2 branches covered.">                    if (array.size() &gt; 0) {</span>
<span class="fc" id="L2453">                        context.object = array;</span>
                    }
                }
<span class="fc" id="L2456">                return;</span>
            }

<span class="fc bfc" id="L2459" title="All 2 branches covered.">            if (!deep) {</span>
<span class="fc" id="L2460">                int matchStat = lexer.seekObjectToField(propertyNameHash, deep);</span>
<span class="fc bfc" id="L2461" title="All 2 branches covered.">                if (matchStat == JSONLexer.VALUE) {</span>
<span class="fc bfc" id="L2462" title="All 2 branches covered.">                    if (context.eval) {</span>
                        Object value;
<span class="pc bpc" id="L2464" title="1 of 4 branches missed.">                        switch (lexer.token()) {</span>
                            case JSONToken.LITERAL_INT:
<span class="fc" id="L2466">                                value = lexer.integerValue();</span>
<span class="fc" id="L2467">                                lexer.nextToken(JSONToken.COMMA);</span>
<span class="fc" id="L2468">                                break;</span>
                            case JSONToken.LITERAL_FLOAT:
<span class="nc" id="L2470">                                value = lexer.decimalValue();</span>
<span class="nc" id="L2471">                                lexer.nextToken(JSONToken.COMMA);</span>
<span class="nc" id="L2472">                                break;</span>
                            case JSONToken.LITERAL_STRING:
<span class="fc" id="L2474">                                value = lexer.stringVal();</span>
<span class="fc" id="L2475">                                lexer.nextToken(JSONToken.COMMA);</span>
<span class="fc" id="L2476">                                break;</span>
                            default:
<span class="fc" id="L2478">                                value = parser.parse();</span>
                                break;
                        }

<span class="pc bpc" id="L2482" title="1 of 2 branches missed.">                        if (context.eval) {</span>
<span class="fc" id="L2483">                            context.object = value;</span>
                        }
                    }
                }
<span class="fc" id="L2487">                return;</span>
            }

            // deep
            for (;;) {
<span class="fc" id="L2492">                int matchStat = lexer.seekObjectToField(propertyNameHash, deep);</span>
<span class="fc bfc" id="L2493" title="All 2 branches covered.">                if (matchStat == JSONLexer.NOT_MATCH) {</span>
<span class="fc" id="L2494">                    break;</span>
                }

<span class="fc bfc" id="L2497" title="All 2 branches covered.">                if (matchStat == JSONLexer.VALUE) {</span>
<span class="pc bpc" id="L2498" title="1 of 2 branches missed.">                    if (context.eval) {</span>
                        Object value;
<span class="fc bfc" id="L2500" title="All 4 branches covered.">                        switch (lexer.token()) {</span>
                            case JSONToken.LITERAL_INT:
<span class="fc" id="L2502">                                value = lexer.integerValue();</span>
<span class="fc" id="L2503">                                lexer.nextToken(JSONToken.COMMA);</span>
<span class="fc" id="L2504">                                break;</span>
                            case JSONToken.LITERAL_FLOAT:
<span class="fc" id="L2506">                                value = lexer.decimalValue();</span>
<span class="fc" id="L2507">                                lexer.nextToken(JSONToken.COMMA);</span>
<span class="fc" id="L2508">                                break;</span>
                            case JSONToken.LITERAL_STRING:
<span class="fc" id="L2510">                                value = lexer.stringVal();</span>
<span class="fc" id="L2511">                                lexer.nextToken(JSONToken.COMMA);</span>
<span class="fc" id="L2512">                                break;</span>
                            default:
<span class="fc" id="L2514">                                value = parser.parse();</span>
                                break;
                        }

<span class="pc bpc" id="L2518" title="1 of 2 branches missed.">                        if (context.eval) {</span>
<span class="pc bpc" id="L2519" title="1 of 2 branches missed.">                            if (context.object instanceof List) {</span>
<span class="fc" id="L2520">                                List list = (List) context.object;</span>
<span class="fc bfc" id="L2521" title="All 4 branches covered.">                                if (list.size() == 0 &amp;&amp; value instanceof List) {</span>
<span class="fc" id="L2522">                                    context.object = value;</span>
                                } else {
<span class="fc" id="L2524">                                    list.add(value);</span>
                                }
<span class="fc" id="L2526">                            } else {</span>
<span class="nc" id="L2527">                                context.object = value;</span>
                            }
                        }
<span class="fc" id="L2530">                    }</span>
<span class="pc bpc" id="L2531" title="1 of 4 branches missed.">                } else if (matchStat == JSONLexer.OBJECT || matchStat == JSONLexer.ARRAY) {</span>
<span class="fc" id="L2532">                    extract(path, parser, context);</span>
                }
<span class="fc" id="L2534">            }</span>
<span class="fc" id="L2535">        }</span>

        public void setValue(JSONPath path, Object parent, Object value) {
<span class="fc bfc" id="L2538" title="All 2 branches covered.">            if (deep) {</span>
<span class="fc" id="L2539">                path.deepSet(parent, propertyName, propertyNameHash, value);</span>
            } else {
<span class="fc" id="L2541">                path.setPropertyValue(parent, propertyName, propertyNameHash, value);</span>
            }
<span class="fc" id="L2543">        }</span>
        
        public boolean remove(JSONPath path, Object parent) {
<span class="fc" id="L2546">            return path.removePropertyValue(parent, propertyName, deep);</span>
        }
    }

    static class MultiPropertySegment implements Segment {

        private final String[] propertyNames;
        private final long[]   propertyNamesHash;

<span class="fc" id="L2555">        public MultiPropertySegment(String[] propertyNames){</span>
<span class="fc" id="L2556">            this.propertyNames = propertyNames;</span>
<span class="fc" id="L2557">            this.propertyNamesHash = new long[propertyNames.length];</span>
<span class="fc bfc" id="L2558" title="All 2 branches covered.">            for (int i = 0; i &lt; propertyNamesHash.length; i++) {</span>
<span class="fc" id="L2559">                propertyNamesHash[i] = TypeUtils.fnv1a_64(propertyNames[i]);</span>
            }
<span class="fc" id="L2561">        }</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2564">            List&lt;Object&gt; fieldValues = new ArrayList&lt;Object&gt;(propertyNames.length);</span>

<span class="fc bfc" id="L2566" title="All 2 branches covered.">            for (int i = 0; i &lt; propertyNames.length; i++) {</span>
<span class="fc" id="L2567">                Object fieldValue = path.getPropertyValue(currentObject, propertyNames[i], propertyNamesHash[i]);</span>
<span class="fc" id="L2568">                fieldValues.add(fieldValue);</span>
            }

<span class="fc" id="L2571">            return fieldValues;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="fc" id="L2575">            JSONLexerBase lexer = (JSONLexerBase) parser.lexer;</span>

            JSONArray array;
<span class="pc bpc" id="L2578" title="1 of 2 branches missed.">            if (context.object == null) {</span>
<span class="fc" id="L2579">                context.object = array = new JSONArray();</span>
            } else {
<span class="nc" id="L2581">                array = (JSONArray) context.object;</span>
            }
<span class="fc bfc" id="L2583" title="All 2 branches covered.">            for (int i = array.size(); i &lt; propertyNamesHash.length; ++i) {</span>
<span class="fc" id="L2584">                array.add(null);</span>
            }

//            if (lexer.token() == JSONToken.LBRACKET) {
//                lexer.nextToken();
//                JSONArray array;
//
//                array = new JSONArray();
//                for (;;) {
//                    if (lexer.token() == JSONToken.LBRACE) {
//                        int index = lexer.seekObjectToField(propertyNamesHash);
//                        int matchStat = lexer.matchStat;
//                        if (matchStat == JSONLexer.VALUE) {
//                            Object value;
//                            switch (lexer.token()) {
//                                case JSONToken.LITERAL_INT:
//                                    value = lexer.integerValue();
//                                    lexer.nextToken();
//                                    break;
//                                case JSONToken.LITERAL_STRING:
//                                    value = lexer.stringVal();
//                                    lexer.nextToken();
//                                    break;
//                                default:
//                                    value = parser.parse();
//                                    break;
//                            }
//
//                            array.add(index, value);
//                            if (lexer.token() == JSONToken.RBRACE) {
//                                lexer.nextToken();
//                                continue;
//                            } else {
//                                lexer.skipObject();
//                            }
//                        } else {
//                            lexer.skipObject();
//                        }
//                    }
//
//                    if (lexer.token() == JSONToken.RBRACKET) {
//                        break;
//                    } else if (lexer.token() == JSONToken.COMMA) {
//                        lexer.nextToken();
//                        continue;
//                    } else {
//                        throw new JSONException(&quot;illegal json.&quot;);
//                    }
//                }
//
//                context.object = array;
//                return;
//            }

            for_:
            for (;;) {
<span class="fc" id="L2640">                int index = lexer.seekObjectToField(propertyNamesHash);</span>
<span class="fc" id="L2641">                int matchStat = lexer.matchStat;</span>
<span class="pc bpc" id="L2642" title="1 of 2 branches missed.">                if (matchStat == JSONLexer.VALUE) {</span>
                    Object value;
<span class="pc bpc" id="L2644" title="3 of 4 branches missed.">                    switch (lexer.token()) {</span>
                        case JSONToken.LITERAL_INT:
<span class="nc" id="L2646">                            value = lexer.integerValue();</span>
<span class="nc" id="L2647">                            lexer.nextToken(JSONToken.COMMA);</span>
<span class="nc" id="L2648">                            break;</span>
                        case JSONToken.LITERAL_FLOAT:
<span class="nc" id="L2650">                            value = lexer.decimalValue();</span>
<span class="nc" id="L2651">                            lexer.nextToken(JSONToken.COMMA);</span>
<span class="nc" id="L2652">                            break;</span>
                        case JSONToken.LITERAL_STRING:
<span class="fc" id="L2654">                            value = lexer.stringVal();</span>
<span class="fc" id="L2655">                            lexer.nextToken(JSONToken.COMMA);</span>
<span class="fc" id="L2656">                            break;</span>
                        default:
<span class="nc" id="L2658">                            value = parser.parse();</span>
                            break;
                    }

<span class="fc" id="L2662">                    array.set(index, value);</span>

<span class="fc bfc" id="L2664" title="All 2 branches covered.">                    if (lexer.token() == JSONToken.COMMA) {</span>
<span class="fc" id="L2665">                        continue for_;</span>
                    }
<span class="fc" id="L2667">                }</span>

                break;
            }
<span class="fc" id="L2671">        }</span>
    }

    static class WildCardSegment implements Segment {
        private boolean deep;
        private boolean objectOnly;

<span class="fc" id="L2678">        private WildCardSegment(boolean deep, boolean objectOnly) {</span>
<span class="fc" id="L2679">            this.deep = deep;</span>
<span class="fc" id="L2680">            this.objectOnly = objectOnly;</span>
<span class="fc" id="L2681">        }</span>

<span class="fc" id="L2683">        public final static WildCardSegment instance = new WildCardSegment(false, false);</span>
<span class="fc" id="L2684">        public final static WildCardSegment instance_deep = new WildCardSegment(true, false);</span>
<span class="fc" id="L2685">        public final static WildCardSegment instance_deep_objectOnly = new WildCardSegment(true, true);</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc bfc" id="L2688" title="All 2 branches covered.">            if (!deep) {</span>
<span class="fc" id="L2689">                return path.getPropertyValues(currentObject);</span>
            }

<span class="fc" id="L2692">            List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L2693">            path.deepGetPropertyValues(currentObject, values);</span>
<span class="fc" id="L2694">            return values;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="pc bpc" id="L2698" title="1 of 2 branches missed.">            if (context.eval) {</span>
<span class="fc" id="L2699">                Object object = parser.parse();</span>
<span class="fc bfc" id="L2700" title="All 2 branches covered.">                if (deep) {</span>
<span class="fc" id="L2701">                    List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();</span>
<span class="fc bfc" id="L2702" title="All 2 branches covered.">                    if (objectOnly) {</span>
<span class="fc" id="L2703">                        path.deepGetObjects(object, values);</span>
                    } else {
<span class="fc" id="L2705">                        path.deepGetPropertyValues(object, values);</span>
                    }
<span class="fc" id="L2707">                    context.object = values;</span>
<span class="fc" id="L2708">                    return;</span>
                }

<span class="fc bfc" id="L2711" title="All 2 branches covered.">                if (object instanceof JSONObject) {</span>
<span class="fc" id="L2712">                    Collection&lt;Object&gt; values = ((JSONObject) object).values();</span>
<span class="fc" id="L2713">                    JSONArray array = new JSONArray(values.size());</span>
<span class="fc" id="L2714">                    array.addAll(values);</span>
<span class="fc" id="L2715">                    context.object = array;</span>
<span class="fc" id="L2716">                    return;</span>
<span class="pc bpc" id="L2717" title="1 of 2 branches missed.">                } else if (object instanceof JSONArray) {</span>
<span class="fc" id="L2718">                    context.object = object;</span>
<span class="fc" id="L2719">                    return;</span>
                }
            }

<span class="nc" id="L2723">            throw new JSONException(&quot;TODO&quot;);</span>
        }
    }

    static class ArrayAccessSegment implements Segment {

        private final int index;

<span class="fc" id="L2731">        public ArrayAccessSegment(int index){</span>
<span class="fc" id="L2732">            this.index = index;</span>
<span class="fc" id="L2733">        }</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2736">            return path.getArrayItem(currentObject, index);</span>
        }

        public boolean setValue(JSONPath path, Object currentObject, Object value) {
<span class="fc" id="L2740">            return path.setArrayItem(path, currentObject, index, value);</span>
        }
        
        public boolean remove(JSONPath path, Object currentObject) {
<span class="fc" id="L2744">            return path.removeArrayItem(path, currentObject, index);</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="fc" id="L2748">            JSONLexerBase lexer = (JSONLexerBase) parser.lexer;</span>
<span class="fc bfc" id="L2749" title="All 4 branches covered.">            if (lexer.seekArrayToItem(index)</span>
                    &amp;&amp; context.eval)
            {
<span class="fc" id="L2752">                context.object = parser.parse();</span>
            }
<span class="fc" id="L2754">        }</span>
    }

    static class MultiIndexSegment implements Segment {

        private final int[] indexes;

<span class="fc" id="L2761">        public MultiIndexSegment(int[] indexes){</span>
<span class="fc" id="L2762">            this.indexes = indexes;</span>
<span class="fc" id="L2763">        }</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2766">            List&lt;Object&gt; items = new JSONArray(indexes.length);</span>
<span class="fc bfc" id="L2767" title="All 2 branches covered.">            for (int i = 0; i &lt; indexes.length; ++i) {</span>
<span class="fc" id="L2768">                Object item = path.getArrayItem(currentObject, indexes[i]);</span>
<span class="fc" id="L2769">                items.add(item);</span>
            }
<span class="fc" id="L2771">            return items;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="nc bnc" id="L2775" title="All 2 branches missed.">            if (context.eval) {</span>
<span class="nc" id="L2776">                Object object = parser.parse();</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">                if (object instanceof List) {</span>
<span class="nc" id="L2778">                    int[] indexes = new int[this.indexes.length];</span>
<span class="nc" id="L2779">                    System.arraycopy(this.indexes, 0, indexes, 0, indexes.length);</span>
<span class="nc bnc" id="L2780" title="All 2 branches missed.">                    boolean noneNegative = indexes[0] &gt;= 0;</span>

<span class="nc" id="L2782">                    List list = (List) object;</span>
<span class="nc bnc" id="L2783" title="All 2 branches missed.">                    if (noneNegative) {</span>
<span class="nc bnc" id="L2784" title="All 2 branches missed.">                        for (int i = list.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L2785" title="All 2 branches missed.">                            if (Arrays.binarySearch(indexes, i) &lt; 0) {</span>
<span class="nc" id="L2786">                                list.remove(i);</span>
                            }
                        }
<span class="nc" id="L2789">                        context.object = list;</span>
<span class="nc" id="L2790">                        return;</span>
                    }
                }
            }
<span class="nc" id="L2794">            throw new UnsupportedOperationException();</span>
        }
    }

    static class RangeSegment implements Segment {
        private final int start;
        private final int end;
        private final int step;

<span class="fc" id="L2803">        public RangeSegment(int start, int end, int step){</span>
<span class="fc" id="L2804">            this.start = start;</span>
<span class="fc" id="L2805">            this.end = end;</span>
<span class="fc" id="L2806">            this.step = step;</span>
<span class="fc" id="L2807">        }</span>

        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc" id="L2810">            int size = SizeSegment.instance.eval(path, rootObject, currentObject);</span>
<span class="pc bpc" id="L2811" title="1 of 2 branches missed.">            int start = this.start &gt;= 0 ? this.start : this.start + size;</span>
<span class="fc bfc" id="L2812" title="All 2 branches covered.">            int end = this.end &gt;= 0 ? this.end : this.end + size;</span>

<span class="fc" id="L2814">            int array_size = (end - start) / step + 1;</span>
<span class="fc bfc" id="L2815" title="All 2 branches covered.">            if (array_size == -1) {</span>
<span class="fc" id="L2816">                return null;</span>
            }

<span class="fc" id="L2819">            List&lt;Object&gt; items = new ArrayList&lt;Object&gt;(array_size);</span>
<span class="fc bfc" id="L2820" title="All 4 branches covered.">            for (int i = start; i &lt;= end &amp;&amp; i &lt; size; i += step) {</span>
<span class="fc" id="L2821">                Object item = path.getArrayItem(currentObject, i);</span>
<span class="fc" id="L2822">                items.add(item);</span>
            }
<span class="fc" id="L2824">            return items;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="nc" id="L2828">            throw new UnsupportedOperationException();</span>
        }
    }

    static class NotNullSegement extends PropertyFilter {
        public NotNullSegement(String propertyName, boolean function){
<span class="fc" id="L2834">            super(propertyName, function);</span>
<span class="fc" id="L2835">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc bfc" id="L2838" title="All 2 branches covered.">            return path.getPropertyValue(item, propertyName, propertyNameHash) != null;</span>
        }
    }

    static class NullSegement extends PropertyFilter {
        public NullSegement(String propertyName, boolean function){
<span class="fc" id="L2844">            super(propertyName, function);</span>
<span class="fc" id="L2845">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L2848">            Object propertyValue = get(path, rootObject, item);</span>

<span class="fc bfc" id="L2850" title="All 2 branches covered.">            return propertyValue == null;</span>
        }
    }
    
    static class ValueSegment extends PropertyFilter {
        private final Object value;
<span class="fc" id="L2856">        private boolean eq = true;</span>
        
        public ValueSegment(String propertyName,boolean function, Object value, boolean eq){
<span class="fc" id="L2859">            super(propertyName, function);</span>

<span class="pc bpc" id="L2861" title="1 of 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L2862">                throw new IllegalArgumentException(&quot;value is null&quot;);</span>
            }
<span class="fc" id="L2864">            this.value = value;</span>
<span class="fc" id="L2865">            this.eq = eq;</span>
<span class="fc" id="L2866">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L2869">            Object propertyValue = get(path, rootObject, item);</span>
<span class="fc" id="L2870">            boolean result = value.equals(propertyValue);</span>
<span class="pc bpc" id="L2871" title="1 of 2 branches missed.">            if (!eq) {</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">                result = !result;</span>
            }
<span class="fc" id="L2874">            return result;</span>
        }
    }

    static class IntInSegement extends PropertyFilter {
        private final long[]  values;
        private final boolean not;

        public IntInSegement(String propertyName, boolean function, long[] values, boolean not){
<span class="fc" id="L2883">            super(propertyName, function);</span>
<span class="fc" id="L2884">            this.values = values;</span>
<span class="fc" id="L2885">            this.not = not;</span>
<span class="fc" id="L2886">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L2889">            Object propertyValue = get(path, rootObject, item);</span>

<span class="pc bpc" id="L2891" title="1 of 2 branches missed.">            if (propertyValue == null) {</span>
<span class="nc" id="L2892">                return false;</span>
            }

<span class="pc bpc" id="L2895" title="1 of 2 branches missed.">            if (propertyValue instanceof Number) {</span>
<span class="fc" id="L2896">                long longPropertyValue = TypeUtils.longExtractValue((Number) propertyValue);</span>
<span class="fc bfc" id="L2897" title="All 2 branches covered.">                for (long value : values) {</span>
<span class="fc bfc" id="L2898" title="All 2 branches covered.">                    if (value == longPropertyValue) {</span>
<span class="pc bpc" id="L2899" title="1 of 2 branches missed.">                        return !not;</span>
                    }
                }
            }

<span class="fc" id="L2904">            return not;</span>
        }
    }

    static class IntBetweenSegement extends PropertyFilter {
        private final long    startValue;
        private final long    endValue;
        private final boolean not;

        public IntBetweenSegement(String propertyName, boolean function, long startValue, long endValue, boolean not){
<span class="fc" id="L2914">            super(propertyName, function);</span>
<span class="fc" id="L2915">            this.startValue = startValue;</span>
<span class="fc" id="L2916">            this.endValue = endValue;</span>
<span class="fc" id="L2917">            this.not = not;</span>
<span class="fc" id="L2918">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L2921">            Object propertyValue = get(path, rootObject, item);</span>

<span class="pc bpc" id="L2923" title="1 of 2 branches missed.">            if (propertyValue == null) {</span>
<span class="nc" id="L2924">                return false;</span>
            }

<span class="pc bpc" id="L2927" title="1 of 2 branches missed.">            if (propertyValue instanceof Number) {</span>
<span class="fc" id="L2928">                long longPropertyValue = TypeUtils.longExtractValue((Number) propertyValue);</span>
<span class="pc bpc" id="L2929" title="1 of 4 branches missed.">                if (longPropertyValue &gt;= startValue &amp;&amp; longPropertyValue &lt;= endValue) {</span>
<span class="fc bfc" id="L2930" title="All 2 branches covered.">                    return !not;</span>
                }
            }

<span class="fc" id="L2934">            return not;</span>
        }
    }

    static class IntObjInSegement extends PropertyFilter {
        private final Long[]  values;
        private final boolean not;

        public IntObjInSegement(String propertyName, boolean function, Long[] values, boolean not){
<span class="fc" id="L2943">            super(propertyName, function);</span>
<span class="fc" id="L2944">            this.values = values;</span>
<span class="fc" id="L2945">            this.not = not;</span>
<span class="fc" id="L2946">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L2949">            Object propertyValue = get(path, rootObject, item);</span>

<span class="fc bfc" id="L2951" title="All 2 branches covered.">            if (propertyValue == null) {</span>
<span class="pc bpc" id="L2952" title="1 of 2 branches missed.">                for (Long value : values) {</span>
<span class="fc bfc" id="L2953" title="All 2 branches covered.">                    if (value == null) {</span>
<span class="pc bpc" id="L2954" title="1 of 2 branches missed.">                        return !not;</span>
                    }
                }

<span class="nc" id="L2958">                return not;</span>
            }

<span class="pc bpc" id="L2961" title="1 of 2 branches missed.">            if (propertyValue instanceof Number) {</span>
<span class="fc" id="L2962">                long longPropertyValue = TypeUtils.longExtractValue((Number) propertyValue);</span>
<span class="fc bfc" id="L2963" title="All 2 branches covered.">                for (Long value : values) {</span>
<span class="fc bfc" id="L2964" title="All 2 branches covered.">                    if (value == null) {</span>
<span class="fc" id="L2965">                        continue;</span>
                    }

<span class="fc bfc" id="L2968" title="All 2 branches covered.">                    if (value.longValue() == longPropertyValue) {</span>
<span class="pc bpc" id="L2969" title="1 of 2 branches missed.">                        return !not;</span>
                    }
                }
            }

<span class="fc" id="L2974">            return not;</span>
        }
    }

    static class StringInSegement extends PropertyFilter {
        private final String[] values;
        private final boolean  not;

        public StringInSegement(String propertyName, boolean function, String[] values, boolean not){
<span class="fc" id="L2983">            super(propertyName, function);</span>
<span class="fc" id="L2984">            this.values = values;</span>
<span class="fc" id="L2985">            this.not = not;</span>
<span class="fc" id="L2986">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L2989">            Object propertyValue = get(path, rootObject, item);</span>

<span class="fc bfc" id="L2991" title="All 2 branches covered.">            for (String value : values) {</span>
<span class="fc bfc" id="L2992" title="All 2 branches covered.">                if (value == propertyValue) {</span>
<span class="pc bpc" id="L2993" title="1 of 2 branches missed.">                    return !not;</span>
<span class="fc bfc" id="L2994" title="All 4 branches covered.">                } else if (value != null &amp;&amp; value.equals(propertyValue)) {</span>
<span class="pc bpc" id="L2995" title="1 of 2 branches missed.">                    return !not;</span>
                }
            }

<span class="fc" id="L2999">            return not;</span>
        }
    }

    static class IntOpSegement extends PropertyFilter {
        private final long     value;
        private final Operator op;

        private BigDecimal     valueDecimal;
        private Float          valueFloat;
        private Double         valueDouble;

        public IntOpSegement(String propertyName, boolean function, long value, Operator op){
<span class="fc" id="L3012">            super(propertyName, function);</span>
<span class="fc" id="L3013">            this.value = value;</span>
<span class="fc" id="L3014">            this.op = op;</span>
<span class="fc" id="L3015">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L3018">            Object propertyValue = get(path, rootObject, item);</span>

<span class="fc bfc" id="L3020" title="All 2 branches covered.">            if (propertyValue == null) {</span>
<span class="fc" id="L3021">                return false;</span>
            }

<span class="pc bpc" id="L3024" title="1 of 2 branches missed.">            if (!(propertyValue instanceof Number)) {</span>
<span class="nc" id="L3025">                return false;</span>
            }

<span class="fc bfc" id="L3028" title="All 2 branches covered.">            if (propertyValue instanceof BigDecimal) {</span>
<span class="fc bfc" id="L3029" title="All 2 branches covered.">                if (valueDecimal == null) {</span>
<span class="fc" id="L3030">                    valueDecimal = BigDecimal.valueOf(value);</span>
                }

<span class="fc" id="L3033">                int result = valueDecimal.compareTo((BigDecimal) propertyValue);</span>
<span class="pc bpc" id="L3034" title="3 of 7 branches missed.">                switch (op) {</span>
                    case EQ:
<span class="fc bfc" id="L3036" title="All 2 branches covered.">                        return result == 0;</span>
                    case NE:
<span class="fc bfc" id="L3038" title="All 2 branches covered.">                        return result != 0;</span>
                    case GE:
<span class="nc bnc" id="L3040" title="All 2 branches missed.">                        return 0 &gt;= result;</span>
                    case GT:
<span class="fc bfc" id="L3042" title="All 2 branches covered.">                        return 0 &gt; result;</span>
                    case LE:
<span class="nc bnc" id="L3044" title="All 2 branches missed.">                        return 0 &lt;= result;</span>
                    case LT:
<span class="fc bfc" id="L3046" title="All 2 branches covered.">                        return 0 &lt; result;</span>
                }

<span class="nc" id="L3049">                return false;</span>
            }

<span class="fc bfc" id="L3052" title="All 2 branches covered.">            if (propertyValue instanceof Float) {</span>
<span class="fc bfc" id="L3053" title="All 2 branches covered.">                if (valueFloat == null) {</span>
<span class="fc" id="L3054">                    valueFloat = Float.valueOf(value);</span>
                }

<span class="fc" id="L3057">                int result = valueFloat.compareTo((Float) propertyValue);</span>
<span class="pc bpc" id="L3058" title="4 of 7 branches missed.">                switch (op) {</span>
                    case EQ:
<span class="fc bfc" id="L3060" title="All 2 branches covered.">                        return result == 0;</span>
                    case NE:
<span class="nc bnc" id="L3062" title="All 2 branches missed.">                        return result != 0;</span>
                    case GE:
<span class="nc bnc" id="L3064" title="All 2 branches missed.">                        return 0 &gt;= result;</span>
                    case GT:
<span class="fc bfc" id="L3066" title="All 2 branches covered.">                        return 0 &gt; result;</span>
                    case LE:
<span class="nc bnc" id="L3068" title="All 2 branches missed.">                        return 0 &lt;= result;</span>
                    case LT:
<span class="fc bfc" id="L3070" title="All 2 branches covered.">                        return 0 &lt; result;</span>
                }

<span class="nc" id="L3073">                return false;</span>
            }

<span class="fc bfc" id="L3076" title="All 2 branches covered.">            if (propertyValue instanceof Double) {</span>
<span class="fc bfc" id="L3077" title="All 2 branches covered.">                if (valueDouble == null) {</span>
<span class="fc" id="L3078">                    valueDouble = Double.valueOf(value);</span>
                }

<span class="fc" id="L3081">                int result = valueDouble.compareTo((Double) propertyValue);</span>
<span class="pc bpc" id="L3082" title="4 of 7 branches missed.">                switch (op) {</span>
                    case EQ:
<span class="fc bfc" id="L3084" title="All 2 branches covered.">                        return result == 0;</span>
                    case NE:
<span class="nc bnc" id="L3086" title="All 2 branches missed.">                        return result != 0;</span>
                    case GE:
<span class="nc bnc" id="L3088" title="All 2 branches missed.">                        return 0 &gt;= result;</span>
                    case GT:
<span class="fc bfc" id="L3090" title="All 2 branches covered.">                        return 0 &gt; result;</span>
                    case LE:
<span class="nc bnc" id="L3092" title="All 2 branches missed.">                        return 0 &lt;= result;</span>
                    case LT:
<span class="fc bfc" id="L3094" title="All 2 branches covered.">                        return 0 &lt; result;</span>
                }

<span class="nc" id="L3097">                return false;</span>
            }

<span class="fc" id="L3100">            long longValue = TypeUtils.longExtractValue((Number) propertyValue);</span>

<span class="pc bpc" id="L3102" title="1 of 7 branches missed.">            switch (op) {</span>
                case EQ:
<span class="fc bfc" id="L3104" title="All 2 branches covered.">                    return longValue == value;</span>
                case NE:
<span class="fc bfc" id="L3106" title="All 2 branches covered.">                    return longValue != value;</span>
                case GE:
<span class="fc bfc" id="L3108" title="All 2 branches covered.">                    return longValue &gt;= value;</span>
                case GT:
<span class="fc bfc" id="L3110" title="All 2 branches covered.">                    return longValue &gt; value;</span>
                case LE:
<span class="fc bfc" id="L3112" title="All 2 branches covered.">                    return longValue &lt;= value;</span>
                case LT:
<span class="fc bfc" id="L3114" title="All 2 branches covered.">                    return longValue &lt; value;</span>
            }

<span class="nc" id="L3117">            return false;</span>
        }
    }

    static abstract class PropertyFilter implements Filter {
<span class="fc" id="L3122">        static long TYPE = TypeUtils.fnv1a_64(&quot;type&quot;);</span>

        protected final String  propertyName;
        protected final long    propertyNameHash;
        protected final boolean function;
        protected Segment functionExpr;

<span class="fc" id="L3129">        protected PropertyFilter(String propertyName, boolean function) {</span>
<span class="fc" id="L3130">            this.propertyName = propertyName;</span>
<span class="fc" id="L3131">            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);</span>
<span class="fc" id="L3132">            this.function = function;</span>

<span class="fc bfc" id="L3134" title="All 2 branches covered.">            if (function) {</span>
<span class="fc bfc" id="L3135" title="All 2 branches covered.">                if (propertyNameHash == TYPE) {</span>
<span class="fc" id="L3136">                    functionExpr = TypeSegment.instance;</span>
<span class="pc bpc" id="L3137" title="1 of 2 branches missed.">                } else if (propertyNameHash == SIZE) {</span>
<span class="fc" id="L3138">                    functionExpr = SizeSegment.instance;</span>
                } else {
<span class="nc" id="L3140">                    throw new JSONPathException(&quot;unsupported funciton : &quot; + propertyName);</span>
                }
            }
<span class="fc" id="L3143">        }</span>

        protected Object get(JSONPath path, Object rootObject, Object currentObject) {
<span class="fc bfc" id="L3146" title="All 2 branches covered.">            if (functionExpr != null) {</span>
<span class="fc" id="L3147">                return functionExpr.eval(path, rootObject, currentObject);</span>
            }
<span class="fc" id="L3149">            return path.getPropertyValue(currentObject, propertyName, propertyNameHash);</span>
        }
    }
    
    static class DoubleOpSegement extends PropertyFilter {
        private final double   value;
        private final Operator op;

        public DoubleOpSegement(String propertyName, boolean function, double value, Operator op){
<span class="fc" id="L3158">            super(propertyName, function);</span>
<span class="fc" id="L3159">            this.value = value;</span>
<span class="fc" id="L3160">            this.op = op;</span>
<span class="fc" id="L3161">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L3164">            Object propertyValue = get(path, rootObject, item);</span>

<span class="pc bpc" id="L3166" title="1 of 2 branches missed.">            if (propertyValue == null) {</span>
<span class="nc" id="L3167">                return false;</span>
            }

<span class="pc bpc" id="L3170" title="1 of 2 branches missed.">            if (!(propertyValue instanceof Number)) {</span>
<span class="nc" id="L3171">                return false;</span>
            }

<span class="fc" id="L3174">            double doubleValue = ((Number) propertyValue).doubleValue();</span>

<span class="pc bpc" id="L3176" title="6 of 7 branches missed.">            switch (op) {</span>
                case EQ:
<span class="fc bfc" id="L3178" title="All 2 branches covered.">                    return doubleValue == value;</span>
                case NE:
<span class="nc bnc" id="L3180" title="All 2 branches missed.">                    return doubleValue != value;</span>
                case GE:
<span class="nc bnc" id="L3182" title="All 2 branches missed.">                    return doubleValue &gt;= value;</span>
                case GT:
<span class="nc bnc" id="L3184" title="All 2 branches missed.">                    return doubleValue &gt; value;</span>
                case LE:
<span class="nc bnc" id="L3186" title="All 2 branches missed.">                    return doubleValue &lt;= value;</span>
                case LT:
<span class="nc bnc" id="L3188" title="All 2 branches missed.">                    return doubleValue &lt; value;</span>
            }

<span class="nc" id="L3191">            return false;</span>
        }
    }

    static class RefOpSegement extends PropertyFilter {
        private final Segment  refSgement;
        private final Operator  op;

        public RefOpSegement(String propertyName, boolean function, Segment refSgement, Operator op){
<span class="fc" id="L3200">            super(propertyName, function);</span>
<span class="fc" id="L3201">            this.refSgement = refSgement;</span>
<span class="fc" id="L3202">            this.op = op;</span>
<span class="fc" id="L3203">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L3206">            Object propertyValue = get(path, rootObject, item);</span>

<span class="pc bpc" id="L3208" title="1 of 2 branches missed.">            if (propertyValue == null) {</span>
<span class="nc" id="L3209">                return false;</span>
            }

<span class="pc bpc" id="L3212" title="1 of 2 branches missed.">            if (!(propertyValue instanceof Number)) {</span>
<span class="nc" id="L3213">                return false;</span>
            }

<span class="fc" id="L3216">            Object refValue = refSgement.eval(path, rootObject, rootObject);</span>

<span class="pc bpc" id="L3218" title="7 of 8 branches missed.">            if (refValue instanceof Integer || refValue instanceof Long || refValue instanceof Short || refValue instanceof Byte) {</span>
<span class="fc" id="L3219">                long value = TypeUtils.longExtractValue((Number) refValue);</span>

<span class="pc bpc" id="L3221" title="4 of 8 branches missed.">                if (propertyValue instanceof Integer || propertyValue instanceof Long || propertyValue instanceof Short || propertyValue instanceof Byte) {</span>
<span class="nc" id="L3222">                    long longValue = TypeUtils.longExtractValue((Number) propertyValue);</span>

<span class="nc bnc" id="L3224" title="All 7 branches missed.">                    switch (op) {</span>
                        case EQ:
<span class="nc bnc" id="L3226" title="All 2 branches missed.">                            return longValue == value;</span>
                        case NE:
<span class="nc bnc" id="L3228" title="All 2 branches missed.">                            return longValue != value;</span>
                        case GE:
<span class="nc bnc" id="L3230" title="All 2 branches missed.">                            return longValue &gt;= value;</span>
                        case GT:
<span class="nc bnc" id="L3232" title="All 2 branches missed.">                            return longValue &gt; value;</span>
                        case LE:
<span class="nc bnc" id="L3234" title="All 2 branches missed.">                            return longValue &lt;= value;</span>
                        case LT:
<span class="nc bnc" id="L3236" title="All 2 branches missed.">                            return longValue &lt; value;</span>
                    }
<span class="pc bpc" id="L3238" title="1 of 2 branches missed.">                } else if (propertyValue instanceof BigDecimal) {</span>
<span class="fc" id="L3239">                    BigDecimal valueDecimal = BigDecimal.valueOf(value);</span>

<span class="fc" id="L3241">                    int result = valueDecimal.compareTo((BigDecimal) propertyValue);</span>
<span class="pc bpc" id="L3242" title="6 of 7 branches missed.">                    switch (op) {</span>
                        case EQ:
<span class="nc bnc" id="L3244" title="All 2 branches missed.">                            return result == 0;</span>
                        case NE:
<span class="nc bnc" id="L3246" title="All 2 branches missed.">                            return result != 0;</span>
                        case GE:
<span class="nc bnc" id="L3248" title="All 2 branches missed.">                            return 0 &gt;= result;</span>
                        case GT:
<span class="nc bnc" id="L3250" title="All 2 branches missed.">                            return 0 &gt; result;</span>
                        case LE:
<span class="fc bfc" id="L3252" title="All 2 branches covered.">                            return 0 &lt;= result;</span>
                        case LT:
<span class="nc bnc" id="L3254" title="All 2 branches missed.">                            return 0 &lt; result;</span>
                    }

<span class="nc" id="L3257">                    return false;</span>
                }
            }

<span class="nc" id="L3261">            throw new UnsupportedOperationException();</span>
        }
    }

    static class MatchSegement extends PropertyFilter {
        private final String   startsWithValue;
        private final String   endsWithValue;
        private final String[] containsValues;
        private final int      minLength;
        private final boolean  not;

        public MatchSegement(
                String propertyName,
                boolean function,
                String startsWithValue,
                String endsWithValue,
                String[] containsValues,
                boolean not)
        {
<span class="fc" id="L3280">            super(propertyName, function);</span>
<span class="fc" id="L3281">            this.startsWithValue = startsWithValue;</span>
<span class="fc" id="L3282">            this.endsWithValue = endsWithValue;</span>
<span class="fc" id="L3283">            this.containsValues = containsValues;</span>
<span class="fc" id="L3284">            this.not = not;</span>

<span class="fc" id="L3286">            int len = 0;</span>
<span class="fc bfc" id="L3287" title="All 2 branches covered.">            if (startsWithValue != null) {</span>
<span class="fc" id="L3288">                len += startsWithValue.length();</span>
            }

<span class="fc bfc" id="L3291" title="All 2 branches covered.">            if (endsWithValue != null) {</span>
<span class="fc" id="L3292">                len += endsWithValue.length();</span>
            }

<span class="fc bfc" id="L3295" title="All 2 branches covered.">            if (containsValues != null) {</span>
<span class="fc bfc" id="L3296" title="All 2 branches covered.">                for (String item : containsValues) {</span>
<span class="fc" id="L3297">                    len += item.length();</span>
                }
            }

<span class="fc" id="L3301">            this.minLength = len;</span>
<span class="fc" id="L3302">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L3305">            Object propertyValue = get(path, rootObject, item);</span>

<span class="fc bfc" id="L3307" title="All 2 branches covered.">            if (propertyValue == null) {</span>
<span class="fc" id="L3308">                return false;</span>
            }

<span class="fc" id="L3311">            final String strPropertyValue = propertyValue.toString();</span>

<span class="fc bfc" id="L3313" title="All 2 branches covered.">            if (strPropertyValue.length() &lt; minLength) {</span>
<span class="fc" id="L3314">                return not;</span>
            }

<span class="fc" id="L3317">            int start = 0;</span>
<span class="fc bfc" id="L3318" title="All 2 branches covered.">            if (startsWithValue != null) {</span>
<span class="fc bfc" id="L3319" title="All 2 branches covered.">                if (!strPropertyValue.startsWith(startsWithValue)) {</span>
<span class="fc" id="L3320">                    return not;</span>
                }
<span class="fc" id="L3322">                start += startsWithValue.length();</span>
            }

<span class="fc bfc" id="L3325" title="All 2 branches covered.">            if (containsValues != null) {</span>
<span class="fc bfc" id="L3326" title="All 2 branches covered.">                for (String containsValue : containsValues) {</span>
<span class="fc" id="L3327">                    int index = strPropertyValue.indexOf(containsValue, start);</span>
<span class="fc bfc" id="L3328" title="All 2 branches covered.">                    if (index == -1) {</span>
<span class="fc" id="L3329">                        return not;</span>
                    }
<span class="fc" id="L3331">                    start = index + containsValue.length();</span>
                }
            }

<span class="fc bfc" id="L3335" title="All 2 branches covered.">            if (endsWithValue != null) {</span>
<span class="fc bfc" id="L3336" title="All 2 branches covered.">                if (!strPropertyValue.endsWith(endsWithValue)) {</span>
<span class="fc" id="L3337">                    return not;</span>
                }
            }

<span class="fc bfc" id="L3341" title="All 2 branches covered.">            return !not;</span>
        }
    }

    static class RlikeSegement extends PropertyFilter {
        private final Pattern pattern;
        private final boolean not;

        public RlikeSegement(String propertyName, boolean function, String pattern, boolean not){
<span class="fc" id="L3350">            super(propertyName, function);</span>
<span class="fc" id="L3351">            this.pattern = Pattern.compile(pattern);</span>
<span class="fc" id="L3352">            this.not = not;</span>
<span class="fc" id="L3353">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L3356">            Object propertyValue = get(path, rootObject, item);</span>

<span class="fc bfc" id="L3358" title="All 2 branches covered.">            if (propertyValue == null) {</span>
<span class="fc" id="L3359">                return false;</span>
            }

<span class="fc" id="L3362">            String strPropertyValue = propertyValue.toString();</span>
<span class="fc" id="L3363">            Matcher m = pattern.matcher(strPropertyValue);</span>
<span class="fc" id="L3364">            boolean match = m.matches();</span>

<span class="fc bfc" id="L3366" title="All 2 branches covered.">            if (not) {</span>
<span class="fc bfc" id="L3367" title="All 2 branches covered.">                match = !match;</span>
            }

<span class="fc" id="L3370">            return match;</span>
        }
    }

    static class StringOpSegement extends PropertyFilter {
        private final String   value;
        private final Operator op;

        public StringOpSegement(String propertyName, boolean function, String value, Operator op){
<span class="fc" id="L3379">            super(propertyName, function);</span>
<span class="fc" id="L3380">            this.value = value;</span>
<span class="fc" id="L3381">            this.op = op;</span>
<span class="fc" id="L3382">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L3385">            Object propertyValue = get(path, rootObject, item);</span>

<span class="fc bfc" id="L3387" title="All 2 branches covered.">            if (op == Operator.EQ) {</span>
<span class="fc" id="L3388">                return value.equals(propertyValue);</span>
<span class="fc bfc" id="L3389" title="All 2 branches covered.">            } else if (op == Operator.NE) {</span>
<span class="fc bfc" id="L3390" title="All 2 branches covered.">                return !value.equals(propertyValue);</span>
            }

<span class="fc bfc" id="L3393" title="All 2 branches covered.">            if (propertyValue == null) {</span>
<span class="fc" id="L3394">                return false;</span>
            }

<span class="fc" id="L3397">            int compareResult = value.compareTo(propertyValue.toString());</span>
<span class="fc bfc" id="L3398" title="All 2 branches covered.">            if (op == Operator.GE) {</span>
<span class="pc bpc" id="L3399" title="1 of 2 branches missed.">                return compareResult &lt;= 0;</span>
<span class="fc bfc" id="L3400" title="All 2 branches covered.">            } else if (op == Operator.GT) {</span>
<span class="fc bfc" id="L3401" title="All 2 branches covered.">                return compareResult &lt; 0;</span>
<span class="fc bfc" id="L3402" title="All 2 branches covered.">            } else if (op == Operator.LE) {</span>
<span class="pc bpc" id="L3403" title="1 of 2 branches missed.">                return compareResult &gt;= 0;</span>
<span class="pc bpc" id="L3404" title="1 of 2 branches missed.">            } else if (op == Operator.LT) {</span>
<span class="fc bfc" id="L3405" title="All 2 branches covered.">                return compareResult &gt; 0;</span>
            }

<span class="nc" id="L3408">            return false;</span>
        }
    }

    static class RegMatchSegement extends PropertyFilter {
        private final Pattern  pattern;
        private final Operator op;

        public RegMatchSegement(String propertyName, boolean function, Pattern pattern, Operator op){
<span class="fc" id="L3417">            super(propertyName, function);</span>
<span class="fc" id="L3418">            this.pattern = pattern;</span>
<span class="fc" id="L3419">            this.op = op;</span>
<span class="fc" id="L3420">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc" id="L3423">            Object propertyValue = get(path, rootObject, item);</span>
<span class="fc bfc" id="L3424" title="All 2 branches covered.">            if (propertyValue == null) {</span>
<span class="fc" id="L3425">                return false;</span>
            }

<span class="fc" id="L3428">            String str = propertyValue.toString();</span>

<span class="fc" id="L3430">            Matcher m = pattern.matcher(str);</span>
<span class="fc" id="L3431">            return m.matches();</span>
        }
    }

<span class="fc" id="L3435">    enum Operator {</span>
<span class="fc" id="L3436">                   EQ, NE, GT, GE, LT, LE, LIKE, NOT_LIKE, RLIKE, NOT_RLIKE, IN, NOT_IN, BETWEEN, NOT_BETWEEN, And, Or, REG_MATCH</span>
    }

    static public class FilterSegment implements Segment {

        private final Filter filter;

        public FilterSegment(Filter filter){
<span class="fc" id="L3444">            super();</span>
<span class="fc" id="L3445">            this.filter = filter;</span>
<span class="fc" id="L3446">        }</span>

        @SuppressWarnings(&quot;rawtypes&quot;)
        public Object eval(JSONPath path, Object rootObject, Object currentObject) {
<span class="pc bpc" id="L3450" title="1 of 2 branches missed.">            if (currentObject == null) {</span>
<span class="nc" id="L3451">                return null;</span>
            }

<span class="fc" id="L3454">            List&lt;Object&gt; items = new JSONArray();</span>

<span class="fc bfc" id="L3456" title="All 2 branches covered.">            if (currentObject instanceof Iterable) {</span>
<span class="fc" id="L3457">                Iterator it = ((Iterable) currentObject).iterator();</span>
<span class="fc bfc" id="L3458" title="All 2 branches covered.">                while (it.hasNext()) {</span>
<span class="fc" id="L3459">                    Object item = it.next();</span>

<span class="fc bfc" id="L3461" title="All 2 branches covered.">                    if (filter.apply(path, rootObject, currentObject, item)) {</span>
<span class="fc" id="L3462">                        items.add(item);</span>
                    }
<span class="fc" id="L3464">                }</span>

<span class="fc" id="L3466">                return items;</span>
            }

<span class="fc bfc" id="L3469" title="All 2 branches covered.">            if (filter.apply(path, rootObject, currentObject, currentObject)) {</span>
<span class="fc" id="L3470">                return currentObject;</span>
            }

<span class="fc" id="L3473">            return null;</span>
        }

        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {
<span class="fc" id="L3477">            Object object = parser.parse();</span>
<span class="fc" id="L3478">            context.object = eval(path, object, object);</span>
<span class="fc" id="L3479">        }</span>

        public boolean remove(JSONPath path, Object rootObject, Object currentObject) {
<span class="pc bpc" id="L3482" title="1 of 2 branches missed.">            if (currentObject == null) {</span>
<span class="nc" id="L3483">                return false;</span>
            }

<span class="pc bpc" id="L3486" title="1 of 2 branches missed.">            if (currentObject instanceof Iterable) {</span>
<span class="fc" id="L3487">                Iterator it = ((Iterable) currentObject).iterator();</span>
<span class="fc bfc" id="L3488" title="All 2 branches covered.">                while (it.hasNext()) {</span>
<span class="fc" id="L3489">                    Object item = it.next();</span>

<span class="pc bpc" id="L3491" title="1 of 2 branches missed.">                    if (filter.apply(path, rootObject, currentObject, item)) {</span>
<span class="fc" id="L3492">                        it.remove();</span>
                    }
<span class="fc" id="L3494">                }</span>

<span class="fc" id="L3496">                return true;</span>
            }

<span class="nc" id="L3499">            return false;</span>
        }
    }

    interface Filter {
        boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item);
    }

    static class FilterGroup implements Filter {
        private boolean and;
        private List&lt;Filter&gt; fitlers;

<span class="fc" id="L3511">        public FilterGroup(Filter left, Filter right, boolean and) {</span>
<span class="fc" id="L3512">            fitlers = new ArrayList&lt;Filter&gt;(2);</span>
<span class="fc" id="L3513">            fitlers.add(left);</span>
<span class="fc" id="L3514">            fitlers.add(right);</span>
<span class="fc" id="L3515">            this.and = and;</span>
<span class="fc" id="L3516">        }</span>

        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {
<span class="fc bfc" id="L3519" title="All 2 branches covered.">            if (and) {</span>
<span class="fc bfc" id="L3520" title="All 2 branches covered.">                for (Filter fitler : this.fitlers) {</span>
<span class="fc bfc" id="L3521" title="All 2 branches covered.">                    if (!fitler.apply(path, rootObject, currentObject, item)) {</span>
<span class="fc" id="L3522">                        return false;</span>
                    }
<span class="fc" id="L3524">                }</span>
<span class="fc" id="L3525">                return true;</span>
            } else {
<span class="fc bfc" id="L3527" title="All 2 branches covered.">                for (Filter fitler : this.fitlers) {</span>
<span class="fc bfc" id="L3528" title="All 2 branches covered.">                    if (fitler.apply(path, rootObject, currentObject, item)) {</span>
<span class="fc" id="L3529">                        return true;</span>
                    }
<span class="fc" id="L3531">                }</span>
<span class="fc" id="L3532">                return false;</span>
            }
        }
    }

    @SuppressWarnings(&quot;rawtypes&quot;)
    protected Object getArrayItem(final Object currentObject, int index) {
<span class="pc bpc" id="L3539" title="1 of 2 branches missed.">        if (currentObject == null) {</span>
<span class="nc" id="L3540">            return null;</span>
        }

<span class="fc bfc" id="L3543" title="All 2 branches covered.">        if (currentObject instanceof List) {</span>
<span class="fc" id="L3544">            List list = (List) currentObject;</span>

<span class="fc bfc" id="L3546" title="All 2 branches covered.">            if (index &gt;= 0) {</span>
<span class="fc bfc" id="L3547" title="All 2 branches covered.">                if (index &lt; list.size()) {</span>
<span class="fc" id="L3548">                    return list.get(index);</span>
                }
<span class="fc" id="L3550">                return null;</span>
            } else {
<span class="fc bfc" id="L3552" title="All 2 branches covered.">                if (Math.abs(index) &lt;= list.size()) {</span>
<span class="fc" id="L3553">                    return list.get(list.size() + index);</span>
                }
<span class="fc" id="L3555">                return null;</span>
            }
        }

<span class="fc bfc" id="L3559" title="All 2 branches covered.">        if (currentObject.getClass().isArray()) {</span>
<span class="fc" id="L3560">            int arrayLenth = Array.getLength(currentObject);</span>

<span class="fc bfc" id="L3562" title="All 2 branches covered.">            if (index &gt;= 0) {</span>
<span class="fc bfc" id="L3563" title="All 2 branches covered.">                if (index &lt; arrayLenth) {</span>
<span class="fc" id="L3564">                    return Array.get(currentObject, index);</span>
                }
<span class="fc" id="L3566">                return null;</span>
            } else {
<span class="fc bfc" id="L3568" title="All 2 branches covered.">                if (Math.abs(index) &lt;= arrayLenth) {</span>
<span class="fc" id="L3569">                    return Array.get(currentObject, arrayLenth + index);</span>
                }
<span class="fc" id="L3571">                return null;</span>
            }
        }

<span class="fc bfc" id="L3575" title="All 2 branches covered.">        if (currentObject instanceof Map) {</span>
<span class="fc" id="L3576">            Map map = (Map) currentObject;</span>
<span class="fc" id="L3577">            Object value = map.get(index);</span>
<span class="pc bpc" id="L3578" title="1 of 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L3579">                value = map.get(Integer.toString(index));</span>
            }
<span class="fc" id="L3581">            return value;</span>
        }

<span class="fc bfc" id="L3584" title="All 2 branches covered.">        if (currentObject instanceof Collection) {</span>
<span class="fc" id="L3585">            Collection collection = (Collection) currentObject;</span>
<span class="fc" id="L3586">            int i = 0;</span>
<span class="pc bpc" id="L3587" title="1 of 2 branches missed.">            for (Object item : collection) {</span>
<span class="fc bfc" id="L3588" title="All 2 branches covered.">                if (i == index) {</span>
<span class="fc" id="L3589">                    return item;</span>
                }
<span class="fc" id="L3591">                i++;</span>
<span class="fc" id="L3592">            }</span>
<span class="nc" id="L3593">            return null;</span>
        }

<span class="pc bpc" id="L3596" title="1 of 2 branches missed.">        if (index == 0) {</span>
<span class="fc" id="L3597">            return currentObject;</span>
        }

<span class="nc" id="L3600">        throw new UnsupportedOperationException();</span>
    }

    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public boolean setArrayItem(JSONPath path, Object currentObject, int index, Object value) {
<span class="fc bfc" id="L3605" title="All 2 branches covered.">        if (currentObject instanceof List) {</span>
<span class="fc" id="L3606">            List list = (List) currentObject;</span>
<span class="pc bpc" id="L3607" title="1 of 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="fc" id="L3608">                list.set(index, value);</span>
            } else {
<span class="nc" id="L3610">                list.set(list.size() + index, value);</span>
            }
<span class="fc" id="L3612">            return true;</span>
        }

<span class="fc" id="L3615">        Class&lt;?&gt; clazz = currentObject.getClass();</span>
<span class="pc bpc" id="L3616" title="1 of 2 branches missed.">        if (clazz.isArray()) {</span>
<span class="fc" id="L3617">            int arrayLenth = Array.getLength(currentObject);</span>

<span class="pc bpc" id="L3619" title="1 of 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="pc bpc" id="L3620" title="1 of 2 branches missed.">                if (index &lt; arrayLenth) {</span>
<span class="fc" id="L3621">                    Array.set(currentObject, index, value);</span>
                }
            } else {
<span class="nc bnc" id="L3624" title="All 2 branches missed.">                if (Math.abs(index) &lt;= arrayLenth) {</span>
<span class="nc" id="L3625">                    Array.set(currentObject, arrayLenth + index, value);</span>
                }
            }

<span class="fc" id="L3629">            return true;</span>
        }

<span class="nc" id="L3632">        throw new JSONPathException(&quot;unsupported set operation.&quot; + clazz);</span>
    }

    @SuppressWarnings(&quot;rawtypes&quot;)
    public boolean removeArrayItem(JSONPath path, Object currentObject, int index) {
<span class="pc bpc" id="L3637" title="1 of 2 branches missed.">        if (currentObject instanceof List) {</span>
<span class="fc" id="L3638">            List list = (List) currentObject;</span>
<span class="pc bpc" id="L3639" title="1 of 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="fc bfc" id="L3640" title="All 2 branches covered.">                if (index &gt;= list.size()) {</span>
<span class="fc" id="L3641">                    return false;</span>
                }
<span class="fc" id="L3643">                list.remove(index);</span>
            } else {
<span class="nc" id="L3645">                int newIndex = list.size() + index;</span>
                
<span class="nc bnc" id="L3647" title="All 2 branches missed.">                if (newIndex &lt; 0) {</span>
<span class="nc" id="L3648">                    return false;</span>
                }
                
<span class="nc" id="L3651">                list.remove(newIndex);</span>
            }
<span class="fc" id="L3653">            return true;</span>
        }

<span class="nc" id="L3656">        Class&lt;?&gt; clazz = currentObject.getClass();</span>
<span class="nc" id="L3657">        throw new JSONPathException(&quot;unsupported set operation.&quot; + clazz);</span>
    }

    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    protected Collection&lt;Object&gt; getPropertyValues(final Object currentObject) {
<span class="pc bpc" id="L3662" title="1 of 2 branches missed.">        if (currentObject == null) {</span>
<span class="nc" id="L3663">            return null;</span>
        }

<span class="fc" id="L3666">        final Class&lt;?&gt; currentClass = currentObject.getClass();</span>

<span class="fc" id="L3668">        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);</span>

<span class="fc bfc" id="L3670" title="All 2 branches covered.">        if (beanSerializer != null) {</span>
            try {
<span class="fc" id="L3672">                return beanSerializer.getFieldValues(currentObject);</span>
<span class="nc" id="L3673">            } catch (Exception e) {</span>
<span class="nc" id="L3674">                throw new JSONPathException(&quot;jsonpath error, path &quot; + path, e);</span>
            }
        }

<span class="fc bfc" id="L3678" title="All 2 branches covered.">        if (currentObject instanceof Map) {</span>
<span class="fc" id="L3679">            Map map = (Map) currentObject;</span>
<span class="fc" id="L3680">            return map.values();</span>
        }

<span class="pc bpc" id="L3683" title="1 of 2 branches missed.">        if (currentObject instanceof Collection) {</span>
<span class="fc" id="L3684">            return (Collection) currentObject;</span>
        }

<span class="nc" id="L3687">        throw new UnsupportedOperationException();</span>
    }

    protected void deepGetObjects(final Object currentObject, List&lt;Object&gt; outValues) {
<span class="fc" id="L3691">        final Class&lt;?&gt; currentClass = currentObject.getClass();</span>

<span class="fc" id="L3693">        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);</span>

<span class="fc" id="L3695">        Collection collection = null;</span>
<span class="pc bpc" id="L3696" title="1 of 2 branches missed.">        if (beanSerializer != null) {</span>
            try {
<span class="nc" id="L3698">                collection = beanSerializer.getFieldValues(currentObject);</span>
<span class="nc" id="L3699">                outValues.add(currentObject);</span>
<span class="nc" id="L3700">            } catch (Exception e) {</span>
<span class="nc" id="L3701">                throw new JSONPathException(&quot;jsonpath error, path &quot; + path, e);</span>
<span class="nc" id="L3702">            }</span>
<span class="fc bfc" id="L3703" title="All 2 branches covered.">        } else if (currentObject instanceof Map) {</span>
<span class="fc" id="L3704">            outValues.add(currentObject);</span>
<span class="fc" id="L3705">            Map map = (Map) currentObject;</span>
<span class="fc" id="L3706">            collection = map.values();</span>
<span class="pc bpc" id="L3707" title="1 of 2 branches missed.">        } else if (currentObject instanceof Collection) {</span>
<span class="fc" id="L3708">            collection = (Collection) currentObject;</span>
        }

<span class="pc bpc" id="L3711" title="1 of 2 branches missed.">        if (collection != null) {</span>
<span class="fc bfc" id="L3712" title="All 2 branches covered.">            for (Object fieldValue : collection) {</span>
<span class="pc bpc" id="L3713" title="1 of 4 branches missed.">                if (fieldValue == null || ParserConfig.isPrimitive2(fieldValue.getClass())) {</span>
                    // skip
                } else {
<span class="fc" id="L3716">                    deepGetObjects(fieldValue, outValues);</span>
                }
<span class="fc" id="L3718">            }</span>
<span class="fc" id="L3719">            return;</span>
        }

<span class="nc" id="L3722">        throw new UnsupportedOperationException(currentClass.getName());</span>
    }

    protected void deepGetPropertyValues(final Object currentObject, List&lt;Object&gt; outValues) {
<span class="fc" id="L3726">        final Class&lt;?&gt; currentClass = currentObject.getClass();</span>

<span class="fc" id="L3728">        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);</span>

<span class="fc" id="L3730">        Collection collection = null;</span>
<span class="pc bpc" id="L3731" title="1 of 2 branches missed.">        if (beanSerializer != null) {</span>
            try {
<span class="nc" id="L3733">                collection = beanSerializer.getFieldValues(currentObject);</span>
<span class="nc" id="L3734">            } catch (Exception e) {</span>
<span class="nc" id="L3735">                throw new JSONPathException(&quot;jsonpath error, path &quot; + path, e);</span>
<span class="nc" id="L3736">            }</span>
<span class="fc bfc" id="L3737" title="All 2 branches covered.">        } else if (currentObject instanceof Map) {</span>
<span class="fc" id="L3738">            Map map = (Map) currentObject;</span>
<span class="fc" id="L3739">            collection = map.values();</span>
<span class="pc bpc" id="L3740" title="1 of 2 branches missed.">        } else if (currentObject instanceof Collection) {</span>
<span class="fc" id="L3741">            collection = (Collection) currentObject;</span>
        }

<span class="pc bpc" id="L3744" title="1 of 2 branches missed.">        if (collection != null) {</span>
<span class="fc bfc" id="L3745" title="All 2 branches covered.">            for (Object fieldValue : collection) {</span>
<span class="pc bpc" id="L3746" title="1 of 4 branches missed.">                if (fieldValue == null || ParserConfig.isPrimitive2(fieldValue.getClass())) {</span>
<span class="fc" id="L3747">                    outValues.add(fieldValue);</span>
                } else {
<span class="fc" id="L3749">                    deepGetPropertyValues(fieldValue, outValues);</span>
                }
<span class="fc" id="L3751">            }</span>
<span class="fc" id="L3752">            return;</span>
        }

<span class="nc" id="L3755">        throw new UnsupportedOperationException(currentClass.getName());</span>
    }

    static boolean eq(Object a, Object b) {
<span class="fc bfc" id="L3759" title="All 2 branches covered.">        if (a == b) {</span>
<span class="fc" id="L3760">            return true;</span>
        }

<span class="pc bpc" id="L3763" title="2 of 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc" id="L3764">            return false;</span>
        }

<span class="fc bfc" id="L3767" title="All 2 branches covered.">        if (a.getClass() == b.getClass()) {</span>
<span class="fc" id="L3768">            return a.equals(b);</span>
        }

<span class="pc bpc" id="L3771" title="1 of 2 branches missed.">        if (a instanceof Number) {</span>
<span class="pc bpc" id="L3772" title="1 of 2 branches missed.">            if (b instanceof Number) {</span>
<span class="fc" id="L3773">                return eqNotNull((Number) a, (Number) b);</span>
            }

<span class="nc" id="L3776">            return false;</span>
        }

<span class="nc" id="L3779">        return a.equals(b);</span>
    }

    @SuppressWarnings(&quot;rawtypes&quot;)
    static boolean eqNotNull(Number a, Number b) {
<span class="fc" id="L3784">        Class clazzA = a.getClass();</span>
<span class="fc" id="L3785">        boolean isIntA = isInt(clazzA);</span>

<span class="fc" id="L3787">        Class clazzB = b.getClass();</span>
<span class="fc" id="L3788">        boolean isIntB = isInt(clazzB);</span>
        
<span class="fc bfc" id="L3790" title="All 2 branches covered.">        if (a instanceof BigDecimal) {</span>
<span class="fc" id="L3791">            BigDecimal decimalA = (BigDecimal) a;</span>
            
<span class="pc bpc" id="L3793" title="1 of 2 branches missed.">            if (isIntB) {</span>
<span class="fc" id="L3794">                return decimalA.equals(BigDecimal.valueOf(TypeUtils.longExtractValue(b)));</span>
            }
        }

<span class="fc bfc" id="L3798" title="All 2 branches covered.">        if (isIntA) {</span>
<span class="fc bfc" id="L3799" title="All 2 branches covered.">            if (isIntB) {</span>
<span class="fc bfc" id="L3800" title="All 2 branches covered.">                return a.longValue() == b.longValue();</span>
            }
            
<span class="pc bpc" id="L3803" title="1 of 2 branches missed.">            if (b instanceof BigInteger) {</span>
<span class="nc" id="L3804">                BigInteger bigIntB = (BigInteger) a;</span>
<span class="nc" id="L3805">                BigInteger bigIntA = BigInteger.valueOf(a.longValue());</span>
                
<span class="nc" id="L3807">                return bigIntA.equals(bigIntB);</span>
            }
        }
        
<span class="fc bfc" id="L3811" title="All 2 branches covered.">        if (isIntB) {</span>
<span class="fc bfc" id="L3812" title="All 2 branches covered.">            if (a instanceof BigInteger) {</span>
<span class="fc" id="L3813">                BigInteger bigIntA = (BigInteger) a;</span>
<span class="fc" id="L3814">                BigInteger bigIntB = BigInteger.valueOf(TypeUtils.longExtractValue(b));</span>
                
<span class="fc" id="L3816">                return bigIntA.equals(bigIntB);</span>
            }
        }
        

<span class="fc" id="L3821">        boolean isDoubleA = isDouble(clazzA);</span>
<span class="fc" id="L3822">        boolean isDoubleB = isDouble(clazzB);</span>

<span class="pc bpc" id="L3824" title="3 of 12 branches missed.">        if ((isDoubleA &amp;&amp; isDoubleB) || (isDoubleA &amp;&amp; isIntB) || (isDoubleB &amp;&amp; isIntA)) {</span>
<span class="fc bfc" id="L3825" title="All 2 branches covered.">            return a.doubleValue() == b.doubleValue();</span>
        }
        

<span class="nc" id="L3829">        return false;</span>
    }

    protected static boolean isDouble(Class&lt;?&gt; clazzA) {
<span class="fc bfc" id="L3833" title="All 4 branches covered.">        return clazzA == Float.class || clazzA == Double.class;</span>
    }

    protected static boolean isInt(Class&lt;?&gt; clazzA) {
<span class="pc bpc" id="L3837" title="1 of 8 branches missed.">        return clazzA == Byte.class || clazzA == Short.class || clazzA == Integer.class || clazzA == Long.class;</span>
    }

    final static long SIZE = 0x4dea9618e618ae3cL; // TypeUtils.fnv1a_64(&quot;size&quot;);
    final static long LENGTH = 0xea11573f1af59eb5L; // TypeUtils.fnv1a_64(&quot;length&quot;);

    protected Object getPropertyValue(Object currentObject, String propertyName, long propertyNameHash) {
<span class="fc bfc" id="L3844" title="All 2 branches covered.">        if (currentObject == null) {</span>
<span class="fc" id="L3845">            return null;</span>
        }

<span class="fc bfc" id="L3848" title="All 2 branches covered.">        if (currentObject instanceof String) {</span>
            try {
<span class="fc" id="L3850">                JSONObject object = (JSONObject) JSON.parse((String) currentObject, parserConfig);</span>
<span class="fc" id="L3851">                currentObject = object;</span>
<span class="nc" id="L3852">            } catch (Exception ex) {</span>
                // skip
<span class="fc" id="L3854">            }</span>
        }

<span class="fc bfc" id="L3857" title="All 2 branches covered.">        if (currentObject instanceof Map) {</span>
<span class="fc" id="L3858">            Map map = (Map) currentObject;</span>
<span class="fc" id="L3859">            Object val = map.get(propertyName);</span>

<span class="pc bpc" id="L3861" title="1 of 6 branches missed.">            if (val == null &amp;&amp; (SIZE == propertyNameHash || LENGTH == propertyNameHash)) {</span>
<span class="fc" id="L3862">                val = map.size();</span>
            }

<span class="fc" id="L3865">            return val;</span>
        }

<span class="fc" id="L3868">        final Class&lt;?&gt; currentClass = currentObject.getClass();</span>

<span class="fc" id="L3870">        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);</span>
<span class="fc bfc" id="L3871" title="All 2 branches covered.">        if (beanSerializer != null) {</span>
            try {
<span class="fc" id="L3873">                return beanSerializer.getFieldValue(currentObject, propertyName, propertyNameHash, false);</span>
<span class="fc" id="L3874">            } catch (Exception e) {</span>
<span class="fc" id="L3875">                throw new JSONPathException(&quot;jsonpath error, path &quot; + path + &quot;, segement &quot; + propertyName, e);</span>
            }
        }

<span class="fc bfc" id="L3879" title="All 2 branches covered.">        if (currentObject instanceof List) {</span>
<span class="fc" id="L3880">            List list = (List) currentObject;</span>

<span class="fc bfc" id="L3882" title="All 4 branches covered.">            if (SIZE == propertyNameHash || LENGTH == propertyNameHash) {</span>
<span class="fc" id="L3883">                return list.size();</span>
            }

<span class="fc" id="L3886">            List&lt;Object&gt; fieldValues = null;</span>

<span class="fc bfc" id="L3888" title="All 2 branches covered.">            for (int i = 0; i &lt; list.size(); ++i) {</span>
<span class="fc" id="L3889">                Object obj = list.get(i);</span>

                //
<span class="pc bpc" id="L3892" title="1 of 2 branches missed.">                if (obj == list) {</span>
<span class="nc bnc" id="L3893" title="All 2 branches missed.">                    if (fieldValues == null) {</span>
<span class="nc" id="L3894">                        fieldValues = new JSONArray(list.size());</span>
                    }
<span class="nc" id="L3896">                    fieldValues.add(obj);</span>
<span class="nc" id="L3897">                    continue;</span>
                }

<span class="fc" id="L3900">                Object itemValue = getPropertyValue(obj, propertyName, propertyNameHash);</span>
<span class="fc bfc" id="L3901" title="All 2 branches covered.">                if (itemValue instanceof Collection) {</span>
<span class="fc" id="L3902">                    Collection collection = (Collection) itemValue;</span>
<span class="fc bfc" id="L3903" title="All 2 branches covered.">                    if (fieldValues == null) {</span>
<span class="fc" id="L3904">                        fieldValues = new JSONArray(list.size());</span>
                    }
<span class="fc" id="L3906">                    fieldValues.addAll(collection);</span>
<span class="pc bpc" id="L3907" title="1 of 4 branches missed.">                } else if (itemValue != null || !ignoreNullValue) {</span>
<span class="fc bfc" id="L3908" title="All 2 branches covered.">                    if (fieldValues == null) {</span>
<span class="fc" id="L3909">                        fieldValues = new JSONArray(list.size());</span>
                    }
<span class="fc" id="L3911">                    fieldValues.add(itemValue);</span>
                }
            }

<span class="fc bfc" id="L3915" title="All 2 branches covered.">            if (fieldValues == null) {</span>
<span class="fc" id="L3916">                fieldValues = Collections.emptyList();</span>
            }

<span class="fc" id="L3919">            return fieldValues;</span>
        }

<span class="fc bfc" id="L3922" title="All 2 branches covered.">        if (currentObject instanceof Object[]) {</span>
<span class="fc" id="L3923">            Object[] array = (Object[]) currentObject;</span>

<span class="pc bpc" id="L3925" title="1 of 4 branches missed.">            if (SIZE == propertyNameHash || LENGTH == propertyNameHash) {</span>
<span class="fc" id="L3926">                return array.length;</span>
            }

<span class="fc" id="L3929">            List&lt;Object&gt; fieldValues = new JSONArray(array.length);</span>

<span class="fc bfc" id="L3931" title="All 2 branches covered.">            for (int i = 0; i &lt; array.length; ++i) {</span>
<span class="fc" id="L3932">                Object obj = array[i];</span>

                //
<span class="pc bpc" id="L3935" title="1 of 2 branches missed.">                if (obj == array) {</span>
<span class="nc" id="L3936">                    fieldValues.add(obj);</span>
<span class="nc" id="L3937">                    continue;</span>
                }

<span class="fc" id="L3940">                Object itemValue = getPropertyValue(obj, propertyName, propertyNameHash);</span>
<span class="pc bpc" id="L3941" title="1 of 2 branches missed.">                if (itemValue instanceof Collection) {</span>
<span class="nc" id="L3942">                    Collection collection = (Collection) itemValue;</span>
<span class="nc" id="L3943">                    fieldValues.addAll(collection);</span>
<span class="pc bpc" id="L3944" title="1 of 4 branches missed.">                } else if (itemValue != null || !ignoreNullValue) {</span>
<span class="fc" id="L3945">                    fieldValues.add(itemValue);</span>
                }
            }

<span class="fc" id="L3949">            return fieldValues;</span>
        }

<span class="fc bfc" id="L3952" title="All 2 branches covered.">        if (currentObject instanceof Enum) {</span>
<span class="fc" id="L3953">            final long NAME = 0xc4bcadba8e631b86L; // TypeUtils.fnv1a_64(&quot;name&quot;);</span>
<span class="fc" id="L3954">            final long ORDINAL = 0xf1ebc7c20322fc22L; //TypeUtils.fnv1a_64(&quot;ordinal&quot;);</span>

<span class="fc" id="L3956">            Enum e = (Enum) currentObject;</span>
<span class="fc bfc" id="L3957" title="All 2 branches covered.">            if (NAME == propertyNameHash) {</span>
<span class="fc" id="L3958">                return e.name();</span>
            }

<span class="pc bpc" id="L3961" title="1 of 2 branches missed.">            if (ORDINAL == propertyNameHash) {</span>
<span class="fc" id="L3962">                return e.ordinal();</span>
            }
        }

<span class="fc bfc" id="L3966" title="All 2 branches covered.">        if (currentObject instanceof Calendar) {</span>
<span class="fc" id="L3967">            final long YEAR = 0x7c64634977425edcL; //TypeUtils.fnv1a_64(&quot;year&quot;);</span>
<span class="fc" id="L3968">            final long MONTH = 0xf4bdc3936faf56a5L; //TypeUtils.fnv1a_64(&quot;month&quot;);</span>
<span class="fc" id="L3969">            final long DAY = 0xca8d3918f4578f1dL; // TypeUtils.fnv1a_64(&quot;day&quot;);</span>
<span class="fc" id="L3970">            final long HOUR = 0x407efecc7eb5764fL; //TypeUtils.fnv1a_64(&quot;hour&quot;);</span>
<span class="fc" id="L3971">            final long MINUTE = 0x5bb2f9bdf2fad1e9L; //TypeUtils.fnv1a_64(&quot;minute&quot;);</span>
<span class="fc" id="L3972">            final long SECOND = 0xa49985ef4cee20bdL; //TypeUtils.fnv1a_64(&quot;second&quot;);</span>

<span class="fc" id="L3974">            Calendar e = (Calendar) currentObject;</span>
<span class="fc bfc" id="L3975" title="All 2 branches covered.">            if (YEAR == propertyNameHash) {</span>
<span class="fc" id="L3976">                return e.get(Calendar.YEAR);</span>
            }
<span class="fc bfc" id="L3978" title="All 2 branches covered.">            if (MONTH == propertyNameHash) {</span>
<span class="fc" id="L3979">                return e.get(Calendar.MONTH);</span>
            }
<span class="fc bfc" id="L3981" title="All 2 branches covered.">            if (DAY == propertyNameHash) {</span>
<span class="fc" id="L3982">                return e.get(Calendar.DAY_OF_MONTH);</span>
            }
<span class="fc bfc" id="L3984" title="All 2 branches covered.">            if (HOUR == propertyNameHash) {</span>
<span class="fc" id="L3985">                return e.get(Calendar.HOUR_OF_DAY);</span>
            }
<span class="fc bfc" id="L3987" title="All 2 branches covered.">            if (MINUTE == propertyNameHash) {</span>
<span class="fc" id="L3988">                return e.get(Calendar.MINUTE);</span>
            }
<span class="pc bpc" id="L3990" title="1 of 2 branches missed.">            if (SECOND == propertyNameHash) {</span>
<span class="fc" id="L3991">                return e.get(Calendar.SECOND);</span>
            }
        }

<span class="fc" id="L3995">        return null;</span>
        //throw new JSONPathException(&quot;jsonpath error, path &quot; + path + &quot;, segement &quot; + propertyName);
    }
    
    @SuppressWarnings(&quot;rawtypes&quot;)
    protected void deepScan(final Object currentObject, final String propertyName, List&lt;Object&gt; results) {
<span class="pc bpc" id="L4001" title="1 of 2 branches missed.">        if (currentObject == null) {</span>
<span class="nc" id="L4002">            return;</span>
        }

<span class="fc bfc" id="L4005" title="All 2 branches covered.">        if (currentObject instanceof Map) {</span>
<span class="fc" id="L4006">            Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) currentObject;</span>

<span class="fc bfc" id="L4008" title="All 2 branches covered.">            for (Map.Entry entry : map.entrySet()) {</span>
<span class="fc" id="L4009">                Object val = entry.getValue();</span>

<span class="fc bfc" id="L4011" title="All 2 branches covered.">                if (propertyName.equals(entry.getKey())) {</span>
<span class="fc bfc" id="L4012" title="All 2 branches covered.">                    if (val instanceof Collection) {</span>
<span class="fc" id="L4013">                        results.addAll((Collection) val);</span>
                    } else {
<span class="fc" id="L4015">                        results.add(val);</span>
                    }
<span class="fc" id="L4017">                    continue;</span>
                }

<span class="fc bfc" id="L4020" title="All 4 branches covered.">                if (val == null || ParserConfig.isPrimitive2(val.getClass())) {</span>
<span class="fc" id="L4021">                    continue;</span>
                }

<span class="fc" id="L4024">                deepScan(val, propertyName, results);</span>
<span class="fc" id="L4025">            }</span>

<span class="fc" id="L4027">            return;</span>
        }

<span class="fc bfc" id="L4030" title="All 2 branches covered.">        if (currentObject instanceof Collection) {</span>
<span class="fc" id="L4031">            Iterator iterator = ((Collection) currentObject).iterator();</span>
<span class="fc bfc" id="L4032" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L4033">                Object next = iterator.next();</span>
<span class="fc bfc" id="L4034" title="All 2 branches covered.">                if (ParserConfig.isPrimitive2(next.getClass())) {</span>
<span class="fc" id="L4035">                    continue;</span>
                }
<span class="fc" id="L4037">                deepScan(next, propertyName, results);</span>
<span class="fc" id="L4038">            }</span>
<span class="fc" id="L4039">            return;</span>
        }

<span class="fc" id="L4042">        final Class&lt;?&gt; currentClass = currentObject.getClass();</span>

<span class="fc" id="L4044">        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);</span>
<span class="pc bpc" id="L4045" title="1 of 2 branches missed.">        if (beanSerializer != null) {</span>
            try {
<span class="fc" id="L4047">                FieldSerializer fieldDeser = beanSerializer.getFieldSerializer(propertyName);</span>
<span class="fc bfc" id="L4048" title="All 2 branches covered.">                if (fieldDeser != null) {</span>
                    try {
<span class="fc" id="L4050">                        Object val = fieldDeser.getPropertyValueDirect(currentObject);</span>
<span class="fc" id="L4051">                        results.add(val);</span>
<span class="fc" id="L4052">                    } catch (InvocationTargetException ex) {</span>
<span class="fc" id="L4053">                        throw new JSONException(&quot;getFieldValue error.&quot; + propertyName, ex);</span>
<span class="nc" id="L4054">                    } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L4055">                        throw new JSONException(&quot;getFieldValue error.&quot; + propertyName, ex);</span>
<span class="fc" id="L4056">                    }</span>
<span class="fc" id="L4057">                    return;</span>
                }
<span class="fc" id="L4059">                List&lt;Object&gt; fieldValues = beanSerializer.getFieldValues(currentObject);</span>
<span class="fc bfc" id="L4060" title="All 2 branches covered.">                for (Object val : fieldValues) {</span>
<span class="fc" id="L4061">                    deepScan(val, propertyName, results);</span>
<span class="fc" id="L4062">                }</span>
<span class="fc" id="L4063">                return;</span>
<span class="fc" id="L4064">            } catch (Exception e) {</span>
<span class="fc" id="L4065">                throw new JSONPathException(&quot;jsonpath error, path &quot; + path + &quot;, segement &quot; + propertyName, e);</span>
            }
        }

<span class="nc bnc" id="L4069" title="All 2 branches missed.">        if (currentObject instanceof List) {</span>
<span class="nc" id="L4070">            List list = (List) currentObject;</span>

<span class="nc bnc" id="L4072" title="All 2 branches missed.">            for (int i = 0; i &lt; list.size(); ++i) {</span>
<span class="nc" id="L4073">                Object val = list.get(i);</span>
<span class="nc" id="L4074">                deepScan(val, propertyName, results);</span>
            }
<span class="nc" id="L4076">            return;</span>
        }
<span class="nc" id="L4078">    }</span>

    protected void deepSet(final Object currentObject, final String propertyName, long propertyNameHash, Object value) {
<span class="pc bpc" id="L4081" title="1 of 2 branches missed.">        if (currentObject == null) {</span>
<span class="nc" id="L4082">            return;</span>
        }

<span class="fc bfc" id="L4085" title="All 2 branches covered.">        if (currentObject instanceof Map) {</span>
<span class="fc" id="L4086">            Map map = (Map) currentObject;</span>

<span class="fc bfc" id="L4088" title="All 2 branches covered.">            if (map.containsKey(propertyName)) {</span>
<span class="fc" id="L4089">                Object val = map.get(propertyName);</span>
<span class="fc" id="L4090">                map.put(propertyName, value);</span>
<span class="fc" id="L4091">                return;</span>
            }

<span class="fc bfc" id="L4094" title="All 2 branches covered.">            for (Object val : map.values()) {</span>
<span class="fc" id="L4095">                deepSet(val, propertyName, propertyNameHash, value);</span>
<span class="fc" id="L4096">            }</span>
<span class="fc" id="L4097">            return;</span>
        }

<span class="fc" id="L4100">        final Class&lt;?&gt; currentClass = currentObject.getClass();</span>

<span class="fc" id="L4102">        JavaBeanDeserializer beanDeserializer = getJavaBeanDeserializer(currentClass);</span>
<span class="fc bfc" id="L4103" title="All 2 branches covered.">        if (beanDeserializer != null) {</span>
            try {
<span class="fc" id="L4105">                FieldDeserializer fieldDeser = beanDeserializer.getFieldDeserializer(propertyName);</span>
<span class="fc bfc" id="L4106" title="All 2 branches covered.">                if (fieldDeser != null) {</span>
<span class="fc" id="L4107">                    fieldDeser.setValue(currentObject, value);</span>
<span class="fc" id="L4108">                    return;</span>
                }

<span class="fc" id="L4111">                JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);</span>
<span class="fc" id="L4112">                List&lt;Object&gt; fieldValues = beanSerializer.getObjectFieldValues(currentObject);</span>
<span class="fc bfc" id="L4113" title="All 2 branches covered.">                for (Object val : fieldValues) {</span>
<span class="fc" id="L4114">                    deepSet(val, propertyName, propertyNameHash, value);</span>
<span class="fc" id="L4115">                }</span>
<span class="fc" id="L4116">                return;</span>
<span class="nc" id="L4117">            } catch (Exception e) {</span>
<span class="nc" id="L4118">                throw new JSONPathException(&quot;jsonpath error, path &quot; + path + &quot;, segement &quot; + propertyName, e);</span>
            }
        }

<span class="pc bpc" id="L4122" title="1 of 2 branches missed.">        if (currentObject instanceof List) {</span>
<span class="fc" id="L4123">            List list = (List) currentObject;</span>

<span class="fc bfc" id="L4125" title="All 2 branches covered.">            for (int i = 0; i &lt; list.size(); ++i) {</span>
<span class="fc" id="L4126">                Object val = list.get(i);</span>
<span class="fc" id="L4127">                deepSet(val, propertyName, propertyNameHash, value);</span>
            }
<span class="fc" id="L4129">            return;</span>
        }
<span class="nc" id="L4131">    }</span>

    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    protected boolean setPropertyValue(Object parent, String name, long propertyNameHash, Object value) {
<span class="fc bfc" id="L4135" title="All 2 branches covered.">        if (parent instanceof Map) {</span>
<span class="fc" id="L4136">            ((Map) parent).put(name, value);</span>
<span class="fc" id="L4137">            return true;</span>
        }

<span class="fc bfc" id="L4140" title="All 2 branches covered.">        if (parent instanceof List) {</span>
<span class="fc bfc" id="L4141" title="All 2 branches covered.">            for (Object element : (List) parent) {</span>
<span class="pc bpc" id="L4142" title="1 of 2 branches missed.">                if (element == null) {</span>
<span class="nc" id="L4143">                    continue;</span>
                }
<span class="fc" id="L4145">                setPropertyValue(element, name, propertyNameHash, value);</span>
<span class="fc" id="L4146">            }</span>
<span class="fc" id="L4147">            return true;</span>
        }

<span class="fc" id="L4150">        ObjectDeserializer deserializer = parserConfig.getDeserializer(parent.getClass());</span>

<span class="fc" id="L4152">        JavaBeanDeserializer beanDeserializer = null;</span>
<span class="pc bpc" id="L4153" title="1 of 2 branches missed.">        if (deserializer instanceof JavaBeanDeserializer) {</span>
<span class="fc" id="L4154">            beanDeserializer = (JavaBeanDeserializer) deserializer;</span>
        }

<span class="pc bpc" id="L4157" title="1 of 2 branches missed.">        if (beanDeserializer != null) {</span>
<span class="fc" id="L4158">            FieldDeserializer fieldDeserializer = beanDeserializer.getFieldDeserializer(propertyNameHash);</span>
<span class="pc bpc" id="L4159" title="1 of 2 branches missed.">            if (fieldDeserializer == null) {</span>
<span class="nc" id="L4160">                return false;</span>
            }

<span class="pc bpc" id="L4163" title="1 of 4 branches missed.">            if (value != null &amp;&amp; value.getClass() != fieldDeserializer.fieldInfo.fieldClass) {</span>
<span class="fc" id="L4164">                value = TypeUtils.cast(value, fieldDeserializer.fieldInfo.fieldType, parserConfig);</span>
            }

<span class="fc" id="L4167">            fieldDeserializer.setValue(parent, value);</span>
<span class="fc" id="L4168">            return true;</span>
        }

<span class="nc" id="L4171">        throw new UnsupportedOperationException();</span>
    }
    
    @SuppressWarnings({&quot;rawtypes&quot; })
    protected boolean removePropertyValue(Object parent, String name, boolean deep) {
<span class="fc bfc" id="L4176" title="All 2 branches covered.">        if (parent instanceof Map) {</span>
<span class="fc" id="L4177">            Object origin = ((Map) parent).remove(name);</span>
<span class="fc bfc" id="L4178" title="All 2 branches covered.">            boolean found = origin != null;</span>

<span class="fc bfc" id="L4180" title="All 2 branches covered.">            if (deep) {</span>
<span class="fc bfc" id="L4181" title="All 2 branches covered.">                for (Object item : ((Map) parent).values()) {</span>
<span class="fc" id="L4182">                    removePropertyValue(item, name, deep);</span>
<span class="fc" id="L4183">                }</span>
            }

<span class="fc" id="L4186">            return found;</span>
        }

<span class="fc" id="L4189">        ObjectDeserializer deserializer = parserConfig.getDeserializer(parent.getClass());</span>

<span class="fc" id="L4191">        JavaBeanDeserializer beanDeserializer = null;</span>
<span class="fc bfc" id="L4192" title="All 2 branches covered.">        if (deserializer instanceof JavaBeanDeserializer) {</span>
<span class="fc" id="L4193">            beanDeserializer = (JavaBeanDeserializer) deserializer;</span>
        }

<span class="fc bfc" id="L4196" title="All 2 branches covered.">        if (beanDeserializer != null) {</span>
<span class="fc" id="L4197">            FieldDeserializer fieldDeserializer = beanDeserializer.getFieldDeserializer(name);</span>

<span class="fc" id="L4199">            boolean found = false;</span>
<span class="fc bfc" id="L4200" title="All 2 branches covered.">            if (fieldDeserializer != null) {</span>
<span class="fc" id="L4201">                fieldDeserializer.setValue(parent, null);</span>
<span class="fc" id="L4202">                found = true;</span>
            }

<span class="fc bfc" id="L4205" title="All 2 branches covered.">            if (deep) {</span>
<span class="fc" id="L4206">                Collection&lt;Object&gt; propertyValues = this.getPropertyValues(parent);</span>
<span class="fc bfc" id="L4207" title="All 2 branches covered.">                for (Object item : propertyValues) {</span>
<span class="fc bfc" id="L4208" title="All 2 branches covered.">                    if (item == null) {</span>
<span class="fc" id="L4209">                        continue;</span>
                    }
<span class="fc" id="L4211">                    removePropertyValue(item, name, deep);</span>
<span class="fc" id="L4212">                }</span>
            }

<span class="fc" id="L4215">            return found;</span>
        }

<span class="pc bpc" id="L4218" title="1 of 2 branches missed.">        if (deep) {</span>
<span class="fc" id="L4219">            return false;</span>
        }

<span class="nc" id="L4222">        throw new UnsupportedOperationException();</span>
    }

    protected JavaBeanSerializer getJavaBeanSerializer(final Class&lt;?&gt; currentClass) {
<span class="fc" id="L4226">        JavaBeanSerializer beanSerializer = null;</span>
        {
<span class="fc" id="L4228">            ObjectSerializer serializer = serializeConfig.getObjectWriter(currentClass);</span>
<span class="fc bfc" id="L4229" title="All 2 branches covered.">            if (serializer instanceof JavaBeanSerializer) {</span>
<span class="fc" id="L4230">                beanSerializer = (JavaBeanSerializer) serializer;</span>
            }
        }
<span class="fc" id="L4233">        return beanSerializer;</span>
    }

    protected JavaBeanDeserializer getJavaBeanDeserializer(final Class&lt;?&gt; currentClass) {
<span class="fc" id="L4237">        JavaBeanDeserializer beanDeserializer = null;</span>
        {
<span class="fc" id="L4239">            ObjectDeserializer deserializer = parserConfig.getDeserializer(currentClass);</span>
<span class="fc bfc" id="L4240" title="All 2 branches covered.">            if (deserializer instanceof JavaBeanDeserializer) {</span>
<span class="fc" id="L4241">                beanDeserializer = (JavaBeanDeserializer) deserializer;</span>
            }
        }
<span class="fc" id="L4244">        return beanDeserializer;</span>
    }

    @SuppressWarnings(&quot;rawtypes&quot;)
    int evalSize(Object currentObject) {
<span class="fc bfc" id="L4249" title="All 2 branches covered.">        if (currentObject == null) {</span>
<span class="fc" id="L4250">            return -1;</span>
        }

<span class="fc bfc" id="L4253" title="All 2 branches covered.">        if (currentObject instanceof Collection) {</span>
<span class="fc" id="L4254">            return ((Collection) currentObject).size();</span>
        }

<span class="fc bfc" id="L4257" title="All 2 branches covered.">        if (currentObject instanceof Object[]) {</span>
<span class="fc" id="L4258">            return ((Object[]) currentObject).length;</span>
        }

<span class="fc bfc" id="L4261" title="All 2 branches covered.">        if (currentObject.getClass().isArray()) {</span>
<span class="fc" id="L4262">            return Array.getLength(currentObject);</span>
        }

<span class="fc bfc" id="L4265" title="All 2 branches covered.">        if (currentObject instanceof Map) {</span>
<span class="fc" id="L4266">            int count = 0;</span>

<span class="fc bfc" id="L4268" title="All 2 branches covered.">            for (Object value : ((Map) currentObject).values()) {</span>
<span class="fc bfc" id="L4269" title="All 2 branches covered.">                if (value != null) {</span>
<span class="fc" id="L4270">                    count++;</span>
                }
<span class="fc" id="L4272">            }</span>
<span class="fc" id="L4273">            return count;</span>
        }

<span class="fc" id="L4276">        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentObject.getClass());</span>

<span class="pc bpc" id="L4278" title="1 of 2 branches missed.">        if (beanSerializer == null) {</span>
<span class="nc" id="L4279">            return -1;</span>
        }

        try {
<span class="fc" id="L4283">            return beanSerializer.getSize(currentObject);</span>
<span class="fc" id="L4284">        } catch (Exception e) {</span>
<span class="fc" id="L4285">            throw new JSONPathException(&quot;evalSize error : &quot; + path, e);</span>
        }
    }

    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    Set&lt;?&gt; evalKeySet(Object currentObject) {
<span class="pc bpc" id="L4291" title="1 of 2 branches missed.">        if (currentObject == null) {</span>
<span class="nc" id="L4292">            return null;</span>
        }

<span class="fc bfc" id="L4295" title="All 2 branches covered.">        if (currentObject instanceof Map) {</span>
            // For performance reasons return keySet directly, without filtering null-value key.
<span class="fc" id="L4297">            return ((Map)currentObject).keySet();</span>
        }

<span class="pc bpc" id="L4300" title="1 of 4 branches missed.">        if (currentObject instanceof Collection || currentObject instanceof Object[]</span>
<span class="pc bpc" id="L4301" title="1 of 2 branches missed.">            || currentObject.getClass().isArray()) {</span>
<span class="fc" id="L4302">            return null;</span>
        }

<span class="fc" id="L4305">        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentObject.getClass());</span>
<span class="pc bpc" id="L4306" title="1 of 2 branches missed.">        if (beanSerializer == null) {</span>
<span class="nc" id="L4307">            return null;</span>
        }

        try {
<span class="fc" id="L4311">            return beanSerializer.getFieldNames(currentObject);</span>
<span class="nc" id="L4312">        } catch (Exception e) {</span>
<span class="nc" id="L4313">            throw new JSONPathException(&quot;evalKeySet error : &quot; + path, e);</span>
        }
    }

    public String toJSONString() {
<span class="fc" id="L4318">        return JSON.toJSONString(path);</span>
    }

    public static Object reserveToArray(Object object, String... paths) {
<span class="fc" id="L4322">        JSONArray reserved = new JSONArray();</span>

<span class="pc bpc" id="L4324" title="2 of 4 branches missed.">        if (paths == null || paths.length == 0) {</span>
<span class="nc" id="L4325">            return reserved;</span>
        }

<span class="fc bfc" id="L4328" title="All 2 branches covered.">        for (String item : paths) {</span>
<span class="fc" id="L4329">            JSONPath path = JSONPath.compile(item);</span>
<span class="fc" id="L4330">            path.init();</span>

<span class="fc" id="L4332">            Object value = path.eval(object);</span>
<span class="fc" id="L4333">            reserved.add(value);</span>
        }

<span class="fc" id="L4336">        return reserved;</span>
    }

    public static Object reserveToObject(Object object, String... paths) {
<span class="pc bpc" id="L4340" title="2 of 4 branches missed.">        if (paths == null || paths.length == 0) {</span>
<span class="nc" id="L4341">            return object;</span>
        }

<span class="fc" id="L4344">        JSONObject reserved = new JSONObject(true);</span>
<span class="fc bfc" id="L4345" title="All 2 branches covered.">        for (String item : paths) {</span>
<span class="fc" id="L4346">            JSONPath path = JSONPath.compile(item);</span>
<span class="fc" id="L4347">            path.init();</span>
<span class="fc" id="L4348">            Segment lastSegement = path.segments[path.segments.length - 1];</span>
<span class="pc bpc" id="L4349" title="1 of 2 branches missed.">            if (lastSegement instanceof PropertySegment) {</span>
<span class="fc" id="L4350">                Object value = path.eval(object);</span>
<span class="fc bfc" id="L4351" title="All 2 branches covered.">                if (value == null) {</span>
<span class="fc" id="L4352">                    continue;</span>
                }
<span class="fc" id="L4354">                path.set(reserved, value);</span>
            } else {
                // skip
            }
        }

<span class="fc" id="L4360">        return reserved;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>